import { of, Subject } from "rxjs";
import { map, flatMap, delay } from "rxjs/operators";
import { Readable } from "stream";
import { IFieldProcessor } from '../src/api/field-processor';
import { CacheHandler } from '../src/api/recorder-config';
import { MemStreamReadableStreamAutoEnd } from "../src/implementation/mem-stream-readable-stream-auto-end";
import { RecorderForDom } from "../src/implementation/native-for-dom";
import { StringBlobOrStream, BlobOrStream, BinaryBlobOrStream, BinaryBlobOrStreamMarker, StringBlobOrStreamMarker } from "../src/api/lazy-ref";

export namespace ForNodeTest {
    export const CacheMap: Map<string, Buffer> = new Map();
    export const CacheHandlerSync: CacheHandler = 
        {
            clearCache: () => {
                CacheMap.clear();
                return of(null);
            },
            getFromCache: (cacheKey) => {
                let buffer = CacheMap.get(cacheKey);
                // let base64AB;
                // if (buffer) {
                //     base64AB = buffer.toString();
                // }
                // let myReadableStreamBuffer;
                // if (base64AB) {
                //     let ws = new memStreams.WritableStream();
                //     ws.write(base64AB);
                //     myReadableStreamBuffer.push(base64AB);
                // }
                let myReadableStreamBuffer = new MemStreamReadableStreamAutoEnd(buffer.toString());

                // myReadableStreamBuffer.addListener('data', (chunk) => {
                //     myReadableStreamBuffer.emit('end');
                // })
                return of(myReadableStreamBuffer);
            },
            putOnCache: (cacheKey, stream) => {
                if(!stream) {
                    throw new Error('Invalid stream: ' + stream);
                }
                let resultSub = new Subject<void>();

                // const isSynchronouslyDone = { value: false };
                // (stream as Readable).on('data', (chunk) => {
                //     isSynchronouslyDone.value = true;
                //     CacheMap.set(cacheKey, chunk);
                //     resultSub.next();
                // });

                if (stream) {
                    return RecorderForDom.blobOrStreamToBuffer(stream).pipe(
                        map(
                            () => {
                                return null;
                            }
                        )
                    );
                } else {
                    return of(null);
                }                

                // if (!isSynchronouslyDone.value) {
                //     return result$;
                // } else {
                //     return of(undefined);
                // };
            },
            removeFromCache: (cacheKey) => {
                CacheMap.delete(cacheKey);
                return of(null);
            }
        };

    export const CacheHandlerAsync: CacheHandler = 
        {
            clearCache: () => {
                return CacheHandlerSync.clearCache().pipe(delay(1));
            },
            getFromCache: (cacheKey) => {
                return CacheHandlerSync.getFromCache(cacheKey).pipe(delay(1));
            },
            putOnCache: (cacheKey, stream) => {
                if(!stream) {
                    throw new Error('Invalid stream: ' + stream);
                }
                return CacheHandlerSync.putOnCache(cacheKey, stream).pipe(delay(1));
            },
            removeFromCache: (cacheKey) => {
                return CacheHandlerSync.removeFromCache(cacheKey).pipe(delay(1));
            }
        };

    export interface CacheHandlerWithInterceptor extends CacheHandler {
        callback: (operation: 'getFromCache' | 'removeFromCache' | 'putOnCache' | 'clearCache', cacheKey?: string, stream?: BlobOrStream) => void
    }
    export function createCacheHandlerWithInterceptor(cacheHandler: CacheHandler): CacheHandlerWithInterceptor {
        CacheMap.clear();
        let newCacheHandler: CacheHandlerWithInterceptor =
        {
            ...cacheHandler,
            callback: () => {}
        }
        newCacheHandler.putOnCache = (cacheKey, stream) => {
            newCacheHandler.callback('putOnCache', cacheKey, stream);
            return cacheHandler.putOnCache(cacheKey, stream);
        }
        newCacheHandler.clearCache = () => {
            newCacheHandler.callback('clearCache');
            return cacheHandler.clearCache();
        }
        newCacheHandler.getFromCache = (cacheKey) => {
            newCacheHandler.callback('getFromCache', cacheKey);
            return cacheHandler.getFromCache(cacheKey);
        }
        newCacheHandler.removeFromCache = (cacheKey) => {
            newCacheHandler.callback('removeFromCache', cacheKey);
            return cacheHandler.removeFromCache(cacheKey);
        }   

        return newCacheHandler;
    }

    export const DateProcessor: IFieldProcessor<Date> = {
        fromLiteralValue: (value) => {
            if (value instanceof Number || typeof(value) === 'number') {
                return new Date(value as number);
            } else if (value instanceof String || typeof(value) === 'string') {
                return new Date(value as string);
            } else {
                return null;
            }
        },
        toLiteralValue: (value) => {
            if (value) {
                return value.getTime();
            } else {
                return null;
            }
        }
    };

    export const BufferProcessor: IFieldProcessor<Buffer> = {
        fromLiteralValue: (value, info) => {
            if (value) {
                return Buffer.from(value, 'base64');
            } else {
                return null;
            }
        },
        fromDirectRaw: (respStream$, info) => {
            return respStream$.pipe(
                flatMap((respStream) => {
                    return RecorderForDom.blobOrStreamToBuffer(respStream.body);
                }),
                map((buffer) => {
                    return { body: buffer };
                })
            );
        },
        toLiteralValue: (value, info) => {
            if (value) {
                let base64Str = value.toString('base64');
                return base64Str;
            } else {
                return null;
            }
        },
        toDirectRaw: (value, info) => {
            if (value) {
                // let ws = new memStreams.WritableStream();
                // ws.write(value);
                let myReadableStreamBuffer = new MemStreamReadableStreamAutoEnd(''); 
                myReadableStreamBuffer.push(value);
                return of({ body: myReadableStreamBuffer} );
                // return of(null).pipe(
                //     tap(() => {
                //         myReadableStreamBuffer.emit('end');
                //     }),
                //     map(() => {
                //         return myReadableStreamBuffer;
                //     })
                // );
            } else {
                return of({ body: null });
            }
        }
    };
    export const StringProcessor: IFieldProcessor<String> = {
        fromLiteralValue: (value, info) => {
            return value;
        },
        fromDirectRaw: (respStream$, info) => {
            return respStream$.pipe(
                flatMap((respStream) => {
                    return RecorderForDom.blobOrStreamToString(respStream.body).pipe(
                        map((bodyStr) => {
                            return { body: bodyStr };
                        })
                    );
                })
            );
        },
        toLiteralValue: (value, info) => {
            return value;
        },
        toDirectRaw: (value, info) => {
            if (value) {
                let myReadableStreamBuffer = new MemStreamReadableStreamAutoEnd(value.toString()); 
                myReadableStreamBuffer.setEncoding('utf-8');
                    return of( { body: myReadableStreamBuffer } );
            } else {
                return of( { body: null });
            }
        }
    };
    export const BinaryBlobOrStreamProcessor: IFieldProcessor<BinaryBlobOrStream> = {
        fromLiteralValue: (value, info) => {
            if (value) {
                return RecorderForDom.b64ToBlobOrStream(value);
            } else {
                return null;
            }
        },
        fromDirectRaw: (respStream$, info) => {
            return respStream$.pipe(
                flatMap((respStream) => {
                    if (respStream.body) {
                        if ((respStream.body as NodeJS.ReadableStream).addListener && (respStream.body as NodeJS.ReadableStream).pipe) {
                            return of(respStream);
                        } else {
                            //for debug purpose
                            info === info
                            throw new Error('Not supported');
                        }
                    } else {
                        return of({ body: null });
                    }
                })
            );
        },
        toDirectRaw: (value, info) => {
            if (value) {
                return of({ body: value });
            } else {
                return of({ body: null });
            }
        },
        toLiteralValue: (value, info) => {
            throw new Error('Not supported!');
        }
    };
    export const StringBlobOrStreamProcessor: IFieldProcessor<StringBlobOrStream> = {
            fromLiteralValue: (value, info) => {
                if (value) {
                    let valueBuffer = Buffer.from(value, 'utf8');
                    // let ws = new memStreams.WritableStream();
                    // ws.write(valueBuffer);
                    let myReadableStreamBuffer = new MemStreamReadableStreamAutoEnd(value); 
                    myReadableStreamBuffer.setEncoding('utf-8');
                    return myReadableStreamBuffer as any as StringBlobOrStream;
                } else {
                    return null;
                }
            },
            fromDirectRaw: (respStream$, info) => {
                return respStream$.pipe(
                    flatMap((respStream) => {
                        if (respStream.body) {
                            if ((respStream.body as NodeJS.ReadableStream).addListener && (respStream.body as NodeJS.ReadableStream).pipe) {
                                (respStream.body as NodeJS.ReadableStream).setEncoding('utf-8');
                                return of(respStream);
                            } else {
                                throw new Error('Not supported');
                            }
                        } else {
                            return of({ body: null});
                        }
                    })
                )
            },
            toDirectRaw: (value, info) => {
                if (value) {
                    return of({ body: value });
                } else {
                    return of({ body: null });
                }
            },
            toLiteralValue: (value, info) => {
                throw new Error('Not supported!');
            }
    };

    // export const BufferProcessor: IFieldProcessor<Buffer> = {
    //     fromLiteralValue: (value, info) => { return BufferProcessor.fromLiteralValue(value, info); },
    //     fromDirectRaw: (stream, info) => { return BufferProcessor.fromDirectRaw(stream, info).pipe(delay(1)); },
    //     toDirectRaw: (value, info) => { return BufferProcessor.toDirectRaw(value, info).pipe(delay(1)); },
    //     toLiteralValue: (value, info) => { return BufferProcessor.toLiteralValue(value, info); }
    // };
    // export const StringProcessor: IFieldProcessor<String> = {
    //         fromLiteralValue: (value, info) => { return StringProcessor.fromLiteralValue(value, info); },
    //         fromDirectRaw: (stream, info) => { return StringProcessor.fromDirectRaw(stream, info).pipe(delay(1)); },
    //         toDirectRaw: (value, info) => { return StringProcessor.toDirectRaw(value, info).pipe(delay(1)); },
    //         toLiteralValue: (value, info) => { return StringProcessor.toLiteralValue(value, info); }
    // };
    // export const BinaryStreamProcessor: IFieldProcessor<BinaryStream> = {
    //         fromLiteralValue: (value, info) => { return BinaryStreamProcessor.fromLiteralValue(value, info); },
    //         fromDirectRaw: (stream, info) => { return BinaryStreamProcessor.fromDirectRaw(stream, info).pipe(delay(1)); },
    //         toDirectRaw: (value, info) => { return BinaryStreamProcessor.toDirectRaw(value, info).pipe(delay(1)); },
    //         toLiteralValue: (value, info) => { return BinaryStreamProcessor.toLiteralValue(value, info); }
    // };
    // export const StringStreamProcessor: IFieldProcessor<StringStream> = {
    //         fromLiteralValue: (value, info) => { return StringStreamProcessor.fromLiteralValue(value, info); },
    //         fromDirectRaw: (stream, info) => { return StringStreamProcessor.fromDirectRaw(stream, info).pipe(delay(1)); },
    //         toDirectRaw: (value, info) => { return StringStreamProcessor.toDirectRaw(value, info).pipe(delay(1)); },
    //         toLiteralValue: (value, info) => { return StringStreamProcessor.toLiteralValue(value, info); }
    // };
    // export const DateProcessor: IFieldProcessor<Date> = {
    //     fromLiteralValue: (value, info) => { return DateSyncProcessor.fromLiteralValue(value, info); },
    //     toLiteralValue: (value, info) => { return DateSyncProcessor.toLiteralValue(value, info); }
    // };

    // export const TypeProcessorEntriesAsync = 
    // [ 
    //     {
    //         type: Buffer,
    //         processor: BufferProcessor
    //     },
    //     {                
    //         type: String,
    //         processor: StringProcessor
    //     },
    //     {                
    //         type: BinaryStreamMarker,
    //         processor: BinaryStreamProcessor
    //     },
    //     {
    //         type: StringStreamMarker,
    //         processor: StringProcessor
    //     },
    //     {
    //         type: Date,
    //         processor: DateProcessor
    //     }
    // ];

    export const TypeProcessorEntries = 
    [ 
        {
            type: Buffer,
            processor: BufferProcessor
        },
        {                
            type: String,
            processor: StringProcessor
        },
        {                
            type: BinaryBlobOrStreamMarker,
            processor: BinaryBlobOrStreamProcessor
        },
        {
            type: StringBlobOrStreamMarker,
            processor: StringProcessor
        },
        {
            type: Date,
            processor: DateSyncProcessor
        }
    ];
}