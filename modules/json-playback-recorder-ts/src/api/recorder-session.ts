import { RecorderManager } from "./recorder-manager";
import { TypeLike, ResponseLike } from "../typeslike";
import { Observable, OperatorFunction, ObservableInput } from "rxjs";
import { Tape, TapeAction } from "./tape";
import { LazyRefImplementor, BlobOrStream, LazyRef } from "./lazy-ref";
import { FieldEtc } from "./field-etc";
import { PlayerMetadatas } from "./player-metadatas";

export interface PlayerSnapshot {
    wrappedSnapshot: any[] | {};
}

export interface EntityRef {
    iAmAnEntityRef: true;
    signatureStr?: string;
    creationId?: number;
}

export interface StringifiableOriginalValueEntry {
    method: 'processResultEntity' | 'processResultEntityArray' | 'newEntityInstance' | 'lazyRef';
    reflectFunctionMetadataTypeKey?: string;
    ownerSignatureStr?: string;
    ownerFieldName?: string;
    playerSnapshot?: PlayerSnapshot;
    attachRefId?: string;
    ref?: EntityRef;
}

export interface SessionState {
    sessionId: string;
    nextCreationId: number;
    stringifiableOriginalValueEntries: Array<StringifiableOriginalValueEntry>
    latestStringifiablePlaybackArr: Array<any>;
    currentStringifiableTape?: Tape;
}

/**
 * Contract
 */
export interface RecorderSession {
    /**
     * Manager.
     */
    manager: RecorderManager;
    /**
     * Process the response body literal object getted from backend.  
     * Body format: PlayerSnapshot.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * it call {@link #storeOriginalStringifiableEntry)} for a future {@link this#restoreEntireState}.  
     * @param entityType - TypeLike<L>
     * @param playerSnapshot a literal object with format PlayerSnapshot
     */
    processPlayerSnapshot<L>(entityType: TypeLike<L>, playerSnapshot: PlayerSnapshot): L;
    /**
     * Process the response body literal for each object getted from backend.  
     * Body format: PlayerSnapshot.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * It call {@link this#storeOriginalStringifiableEntry} for a future {@link this#restoreEntireState}.  
     *
     * @param entityType - TypeLike<L>
     * @param playerSnapshot - PlayerSnapshot
     * @returns Array<L>
     */
    processPlayerSnapshotArray<L>(entityType: TypeLike<L>, playerSnapshot: PlayerSnapshot): Array<L>;
    /**
     * Generate a managed instance for type T.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the T instance.
     * 
     * @param entityType - \{TypeLike<T>\} 
     * @returns T
     */
    newEntityInstance<T extends object>(entityType: TypeLike<T>): T;
    /**
     * Start recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedTape}  
     * See: {@link this#getLastRecordedStringifiableTape}
     */
    startRecording(): void;
    /**
     * Stop recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedTape}  
     * See: {@link this#getLastRecordedStringifiableTape}
     */
    stopRecording(): void;
    /**
     * Generate recoverable JSONParsable literal object that can be used
     * on {@link this#restoreEntireState} to restore the session
     * state including all cached entity instances and all modifications.
     *
     * @returns recoverable JSONParsable literal object
     */
    generateEntireStringifiableState(): Observable<SessionState>;
    /**
     * Restore the session state using the object state generated by
     * {@link this#generateEntireStringifiableState}.
     *
     * @param {*} literalState
     */
    restoreEntireState(literalState: SessionState): void;
    /**
     * Creates a recoverable JSONParsable literal object that can be used
     * after {@link this#restoreEntireState} on
     * {@link this#getEntityInstanceFromRef}.
     *
     * @param realEntity - T
     */
    createStringifiableRefForEntity<T>(realEntity: T): EntityRef;
    /**
     * Get the managed instance for literalRef  
     * 
     * See:  
     * {@link this#generateEntireStringifiableState}  
     * {@link this#restoreEntireState}  
     * {@link this#createStringifiableRefForEntity}  
     *
     * @param literalRef - any
     * @returns
     */
    getEntityInstanceFromRef<T>(literalRef: EntityRef): T;
    /**
     * Get all recorded modifications between last calls for {@link this#startRecording} 
     * and {@link this#stopRecording}.
     *
     * @returns {ITape}
     */
    getLastRecordedTape(): Tape;
    getLastRecordedStreams(): Map<String, Observable<BlobOrStream>>;
    getLastRecordedTapeAndStreams(): {tape: Tape, streams: Map<String, Observable<BlobOrStream>>};
    /**
     * Equivalent to {@link this#getLastRecordedTape} with recoverable
     * JSONParsable literal object return.
     *
     * @returns
     */
    getLastRecordedStringifiableTape(): Tape;
    /**
     * 
     */
    getLastRecordedStringifiableTapeAndStreams(): {stringifiableTape: Tape, streams: Map<String, Observable<BlobOrStream>>};
    /**
     * Record action equivalente to 'org.hibernate.Session.save()'.
     *
     * @param entity - 
     */
    recordSave(entity: any): void;
    /**
     * Record action equivalente to 'org.hibernate.Session.delete()'.
     *
     * @param entity -
     */
    recordDelete(entity: any): void;
    /**
     * Clear/release all data for the session including cached e modifications recorded.
     */
    clear(): Observable<void>;
    /**
     * Switch off the the modifying notification for this entity.  
     * Each entity property set trigger {@link LazyRef#next} for all related 
     * {@link LazyRef}, so this can introduce some script over processing,
     * this method is a workaround for this problem.
     * 
     * @param entity 
     */
    switchOffNotifyAllLazyrefs(entity: object): void;
    /**
     * Switch on the the modifying notification for this entity.  
     * Calls {@link this#notifyAllLazyrefsAboutEntityModification}.  
     * See {@link this#switchOffNotifyAllLazyrefs}.
     * @param entity 
     */
    switchOnNotifyAllLazyrefs(entity: object): void;
    getLastRecordedAtaches(): Map<String, Observable<BlobOrStream>>;
    // /**
    //  * Generate an Observable for waiting all internal async task.  
    //  * Use it be notified about completion of all inernal async tasks.
    //  */
    // createAsyncTasksWaiting(): Observable<void>;
    // /**
    //  * Generate an Observable for waiting all internal async task.  
    //  * Each observable is just started after before.  
    //  * Use it be notified about completion of all inernal async tasks.
    //  */
    // createSerialAsyncTasksWaiting(): Observable<void>;
    /**
     * Generate an Observable for waiting all internal async task.  
     * Each observable is just started after before.  
     * Use it be notified about completion of all inernal async tasks.  
     *   
     * IMPORTANT.:
     */
    createPendingTasksWaiting(): Observable<void>;
}

/**
 * Contract
 */
export interface RecorderSessionImplementor extends RecorderSession {
    /** Framework internal use. */
    isOnRestoreEntireState(): boolean;
    /** Framework internal use. */
    mapJustOnceKeepAllFlagsRxOpr<T, R>(lazyLoadedObj: any, project: (value: T, index?: number) => R, thisArg?: any): OperatorFunction<T, R>;
    /** Framework internal use. */
    mapKeepAllFlagsRxOpr<T, R>(lazyLoadedObj: any, project: (value: T, index?: number) => R, thisArg?: any): OperatorFunction<T, R>;
    /** Framework internal use. */
    flatMapJustOnceKeepAllFlagsRxOpr<T, R>(lazyLoadedObj: any, project: (value: T, index?: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;
    ///** Framework internal use. */
    //combineFirstSerialPreserveAllFlags(obsArr: Observable<any>[], lazyLoadedObj?: any): Observable<any>;
    /** Framework internal use. */
    flatMapKeepAllFlagsRxOpr<T, R>(lazyLoadedObj: any, project: (value: T, index?: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;
    /** Framework internal use. */
    getCachedBySignature<T extends object>(signatureStr: string): T;
    /** Framework internal use. */
    addTapeAction(action: TapeAction): void;
    /** Framework internal use. */
    isRecording(): boolean;
    /** Framework internal use. */
    storeOriginalStringifiableEntry(originalValueEntry: StringifiableOriginalValueEntry, signature?: string): void;
    /** Framework internal use. */
    tryCacheInstanceBySignature(
        tryOptions:
            {
                realInstance: any,
                playerSnapshot: PlayerSnapshot,
                lazySignature?: string
            }): void;
    validatePlayerSideLiteralObject(literalObject: {}): void;
    validatePlayerSideResponseLike(responseLike: ResponseLike<{} | BlobOrStream>): void;
    /**
     * Framework internal use.
     */
    processWrappedSnapshotFieldInternal<L>(entityType: TypeLike<L>, wrappedSnapshotField: any): L;
    /**
     * Framework internal use. Used exclusively in lazy load.
     */
    processWrappedSnapshotFieldArrayInternal<L>(entityType: TypeLike<L>, lazyLoadedColl: any, wrappedSnapshotField: any[]): void;
    /** Framework internal use.  Collection utility. */
    createCollection(collType: TypeLike<any>, refererObj: any, refererKey: string): any;
    /** Framework internal use.  Collection utility. */
    isCollection(typeTested: TypeLike<any>): any;
    /** Framework internal use.  Collection utility. */
    addOnCollection(collection: any, element: any): void;
    /** Framework internal use.  Collection utility. */
    removeFromCollection(collection: any, element: any): void;
    /** Framework internal use. */
    registerEntityAndLazyref(entity: object, LazyRefImplementor: LazyRefImplementor<any, any>): void;
    /** Framework internal use. */
    unregisterEntityAndLazyref(entity: object, lazyRef: LazyRefImplementor<any, any>): void;
    /** Framework internal use. */
    nextMultiPurposeInstanceId(): number;
    /** Framework internal use. */
    notifyAllLazyrefsAboutEntityModification(entity: object, lazyRef: LazyRefImplementor<any, any>): void;
    /** Framework internal use. */
    recordAtache(attach: Observable<BlobOrStream>): string;
    /** Framework internal use. */
    fielEtcCacheMap: Map<Object, Map<String, FieldEtc<any, any>>>;
    /** Framework internal use. */
    logRxOpr<T>(id: string): OperatorFunction<T, T>;
    /** Framework internal use. All framework internal pipe over provided observables.  
     * Note that it is piped just for Observables that are provided for framework  
     * extension points, like IFieldProcessor.fromLiteralValue, are internaly subscribed.  
     * Observables from:  
     * - IFieldProcessor.fromLiteralValue
     * - IFieldProcessor.fromRecordedStringifiableValue
     * - IFieldProcessor.fromDirectRaw
     * - IFieldProcessor.toLiteralValue
     * - IFieldProcessor.toDirectRaw
     * - CacheHandler.getFromCache
     * - CacheHandler.removeFromCache
     * - CacheHandler.putOnCache
     * - CacheHandler.clearCache
     * - LazyObservableProvider.generateObservable
     * - LazyObservableProvider.generateObservableForDirectRaw
     */
    // addSubscribedObsRxOpr<T>(): OperatorFunction<T, T>;
    registerProvidedObservablesRxOpr<T>(): OperatorFunction<T, T>;
    /** Framework internal use. This Operator replace internal subscribe call.*/
    // doSubriscribeWithProvidedObservableRxOpr<T>(observer?: PartialObserver<T>): OperatorFunction<T, T>;
    // doSubriscribeWithProvidedObservableRxOpr<T>(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): OperatorFunction<T, T>;
    /**
     * Framework internal use.  
     * This put the PlayerMetadatas's on options.refMap by PlayerMetadatas#$id$  
     * and resolves PlayerMetadatas's by PlayerMetadatas#$idRef$ if it exists.
     */
    resolveMetadatas(
        options: 
            {
                object?: any,
                literalObject?: any,
                key?: string,
                refererObject?: Object,
                refererLiteralObject?: any,
                refMap?: Map<Number, any>
            }) :
            {
                refererObjMd: PlayerMetadatas,
                objectMd: PlayerMetadatas,
                playerObjectIdMd: PlayerMetadatas,
                refererObjMdFound: boolean,
                objectMdFound: boolean,
                playerObjectIdMdFound: boolean
            };
    processTapeActionAttachRefId<T>(
        options:
            {
                action: TapeAction,
                fieldEtc: FieldEtc<T, any>,
                value: T,
                propertyKey: string
            }) : 
            Observable<
                {
                    asyncAddTapeAction: boolean,
                    newValue: T
                }
            >;
    jsonStringfyWithMax(literalObj: any): string;
    //2020-12-08T06:12:03.862Z: There is no reason for it to exist, that I remember
    // /** Framework internal use. */
    // registerLazyRefSubscriptionRxOpr<L>(signature: string):  OperatorFunction<L, L>;
    /** Framework internal use. */
    setLazyRefRespObs<L extends Object, I>(lazyRef: LazyRefImplementor<L, I>): void;
}