import { RecorderManager } from "./recorder-manager";
import { TypeLike } from "../typeslike";
import { Observable } from "rxjs";
import { Stream } from "stream";
import { Tape } from "./tape";

export interface PlayerSnapshot {
    wrappedSnapshot: any[] | {};
}

export interface EntityRef {
    iAmAnEntityRef: true;
    signatureStr?: string;
    creationId?: number;
}

export interface OriginalLiteralValueEntry {
    method: 'processResultEntity' | 'processResultEntityArray' | 'newEntityInstance' | 'lazyRef';
    reflectFunctionMetadataTypeKey?: string;
    ownerSignatureStr?: string;
    ownerFieldName?: string;
    playerSnapshot?: PlayerSnapshot;
    attachRefId?: string;
    ref?: EntityRef;
}

export interface SessionState {
    sessionId: string;
    nextCreationId: number;
    originalLiteralValueEntries: Array<OriginalLiteralValueEntry>
    latestPlaybackArrAsLiteral: Array<any>;
    currentTapeAsLiteral?: any;
}

/**
 * Contract
 */
export interface RecorderSession {
    /**
     * Manager.
     */
    manager: RecorderManager;
    /**
     * Process the response body literal object getted from backend.  
     * Body format: PlayerSnapshot.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * it call {@link #storeOriginalLiteralEntry)} for a future {@link this#restoreEntireStateFromLiteral}.  
     * @param entityType - TypeLike<L>
     * @param playerSnapshot a literal object with format PlayerSnapshot
     */
    processPlayerSnapshot<L>(entityType: TypeLike<L>, playerSnapshot: PlayerSnapshot): Observable<L>;
    /**
     * Process the response body literal for each object getted from backend.  
     * Body format: PlayerSnapshot.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * It call {@link this#storeOriginalLiteralEntry} for a future {@link this#restoreEntireStateFromLiteral}.  
     *
     * @param entityType - TypeLike<L>
     * @param playerSnapshot - PlayerSnapshot
     * @returns Array<L>
     */
    processPlayerSnapshotArray<L>(entityType: TypeLike<L>, playerSnapshot: PlayerSnapshot): Observable<Array<L>>;
    /**
     * Generate a managed instance for type T.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the T instance.
     * 
     * @param entityType - \{TypeLike<T>\} 
     * @returns T
     */
    newEntityInstance<T extends object>(entityType: TypeLike<T>): Observable<T>;
    /**
     * Start recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedTape}  
     * See: {@link this#getLastRecordedTapeAsLiteral}
     */
    startRecording(): void;
    /**
     * Stop recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedTape}  
     * See: {@link this#getLastRecordedTapeAsLiteral}
     */
    stopRecording(): void;
    /**
     * Generate recoverable JSONParsable literal object that can be used
     * on {@link this#restoreEntireStateFromLiteral} to restore the session
     * state including all cached entity instance and all modifications.
     *
     * @returns recoverable JSONParsable literal object
     */
    generateEntireStateAsLiteral(): Observable<any>;
    /**
     * Restore the session state using the object state generated by
     * {@link this#getEntireStateAsLiteral}.
     *
     * @param {*} literalState
     */
    restoreEntireStateFromLiteral(literalState: any):  Observable<void>;
    /**
     * Creates a recoverable JSONParsable literal object that can be used
     * after {@link this#restoreEntireStateFromLiteral} on
     * {@link this#getEntityInstanceFromLiteralRef}.
     *
     * @param realEntity - T
     */
    createLiteralRefForEntity<T>(realEntity: T): any;
    /**
     * Get the managed instance for literalRef  
     * 
     * See:  
     * {@link this#generateEntireStateAsLiteral}  
     * {@link this#restoreEntireStateFromLiteral}  
     * {@link this#createLiteralRefForEntity}  
     *
     * @param literalRef - any
     * @returns
     */
    getEntityInstanceFromLiteralRef<T>(literalRef: any): T;
    /**
     * Get all recorded modifications between last calls for {@link this#startRecording} 
     * and {@link this#stopRecording}.
     *
     * @returns {ITape}
     */
    getLastRecordedTape(): Observable<Tape>;
    getLastRecordedStreams(): Observable<Map<String, NodeJS.ReadableStream>>;
    getLastRecordedTapeAndStreams(): Observable<{tape: Tape, streams: Map<String, NodeJS.ReadableStream>}>;
    /**
     * Equivalent to {@link this#getLastRecordedTape} with recoverable
     * JSONParsable literal object return.
     *
     * @returns
     */
    getLastRecordedTapeAsLiteral(): Observable<any>;
    getLastRecordedTapeAsLiteralAndStreams(): Observable<{tapeLiteral: any, streams: Map<String, NodeJS.ReadableStream>}>;
    /**
     * Record action equivalente to 'org.hibernate.Session.save()'.
     *
     * @param entity - 
     */
    recordSave(entity: any): void;
    /**
     * Record action equivalente to 'org.hibernate.Session.delete()'.
     *
     * @param entity -
     */
    recordDelete(entity: any): void;
    /**
     * Clear/release all data for the session including cached e modifications recorded.
     */
    clear(): void;
    /**
     * Switch off the the modifying notification for this entity.  
     * Each entity property set trigger {@link LazyRef#next} for all related 
     * {@link LazyRef}, so this can introduce some script over processing,
     * this method is a workaround for this problem.
     * 
     * @param entity 
     */
    switchOffNotifyAllLazyrefs(entity: object): void;
    /**
     * Switch on the the modifying notification for this entity.  
     * Calls {@link this#notifyAllLazyrefsAboutEntityModification}.  
     * See {@link this#switchOffNotifyAllLazyrefs}.
     * @param entity 
     */
    switchOnNotifyAllLazyrefs(entity: object): void;
    getLastRecordedAtaches(): Map<String, NodeJS.ReadableStream>;
    /**
     * Generate an Observable for waiting all internal async task.  
     * Use it be notified about completion of all inernal async tasks.
     */
    createAsyncTasksWaiting(): Observable<void>;
    /**
     * Generate an Observable for waiting all internal async task.  
     * Each observable is just started after before.  
     * Use it be notified about completion of all inernal async tasks.
     */
    createSerialAsyncTasksWaiting(): Observable<void>;
}