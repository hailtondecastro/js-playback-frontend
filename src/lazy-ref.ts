import { Observable, Subscription, Subject, Subscriber, of as observableOf } from 'rxjs';
import { PartialObserver } from 'rxjs/Observer';
import { GenericNode, GenericTokenizer } from './generic-tokenizer';
import { Type } from '@angular/core';
import { JsHbPlaybackAction, JsHbPlaybackActionType } from './js-hb-playback-action';
import { IJsHbSession, JsHbEntityRef } from './js-hb-session';
import { JsHbLogLevel } from './js-hb-config';
import { get as lodashGet, has as lodashHas, set as lodashSet } from 'lodash';
import { flatMap } from 'rxjs/operators';
import { HttpResponse } from '@angular/common/http';
import { JsHbContants } from './js-hb-constants';

/**
 * Base class to use as marker for {@link reflect-metadata#Reflect.metadata} with 
 * {@link ./generic-tokenizer#GenericTokenizer GenericTokenizer}.
 * 
 * Do not use this as the field type, use {@link LazyRefMTO} or {@link LazyRefOTM}.
 * Use this as 'interface like' to do your own implementation if you need! 
 * See {@link IJsHbSession#createApropriatedLazyRef}
 * 
 * Code sample:
 * ```ts
   ...
   private _myChildEntitiesSet(): LazyRefOTM<Set<MyChildEntity>>;
   @NgJsHbDecorators.property()
   @Reflect.metadata('design:generics', new GenericNodeNotNow(() => GenericTokenizer.create().tp(LazyRef).lt().tp(Set).lt().tp(MyChildEntity).gt().gt().tree))
   public get myChildEntitiesSet(): LazyRefOTM<Set<MyChildEntity>> {
     return this._myChildEntitiesSet;
   }
   ...
 * ```
 * or
 * ```ts
   ...
   private _myParentEntity(): LazyRefMTO<MyParentEntity, Number>;
   @NgJsHbDecorators.property()
   @Reflect.metadata('design:generics', new GenericNodeNotNow(() => GenericTokenizer.create().tp(LazyRef).lt().tp(MyParentEntity).comma().tp(Number).gt().tree))
   public get myParentEntity(): LazyRefMTO<MyParentEntity, Number> {
     return this._myParentEntity;
   }
   ...
 * ```
 */
export class LazyRef<L extends object, I> extends Subject<L> {
    /**
     * Alternative to instance of.
     */
    iAmLazyRef: boolean = true;
    /**
     * Hibernate id. This is accessible even before lazy loading.
     */
    hbId: I;
    //lazyLoadedObj: L;
    /**
     * Signature identifier generated by backend server.
     */
    signatureStr: string;
    /**
     * Unlike the common subscribe, which must be executed every time the data
     * changed, it is only executed once and triggers a next to
     * that all other subscriptions (pipe async's for example) are called.
     * so it does not return Subscription, after all it does not subscribe permanently
     * on the observer's list.  
     * Call {@link IJsHbSession#notifyAllLazyrefsAboutEntityModification} after modification and {@link Subscription#unsubscribe}.
     * @param observerOrNext
     * @param error
     * @param complete
     */
    subscribeToModify(observer?: PartialObserver<L>): void;
    subscribeToModify(next?: (value: L) => void, error?: (error: any) => void, complete?: () => void): void;
    subscribeToModify(): void { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); }
    /**
     * TODO:
     * @param lazyLoadedObj 
     */
    setLazyObj(lazyLoadedObj: L): void { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /** Framework internal use. */
    setLazyObjOnLazyLoading(lazyLoadedObj: L): void { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /** Framework internal use. */
    setLazyObjNoNext(lazyLoadedObj: L) : void { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /** Framework internal use. */
    notifyModification(lazyLoadedObj: L) : void { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /**
     * true if it is lazy loaded.
     * @returns true if it is lazy loaded.
     */
    isLazyLoaded(): boolean { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    isOnSubscribeToModify(): boolean { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /** 
     * TODO:  
     * Framework internal use.
     */
    processResponse(responselike: { body: any }): L { throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!'); };
    /** Framework internal use. */
    get genericNode(): GenericNode {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
    set genericNode(value: GenericNode) {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public get refererObj(): any {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public set refererObj(value: any) {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public get refererKey(): string {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public set refererKey(value: string) {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public get session(): IJsHbSession {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public set session(value: IJsHbSession) {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
	public get lazyLoadedObj(): L {
		throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
    public get respObs(): Observable<HttpResponse<Object>> {
        throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }
    /** Framework internal use. */
    public set respObs(value: Observable<HttpResponse<Object>>) {
        throw new Error('LazyRef is not the real implementation base, Do not instantiate it!!');
    }

    public toString(): string {
        let thisLocal = this;
        return JSON.stringify(
            {
                instanceId: (thisLocal as any).instanceId,
                iAmLazyRef: thisLocal.iAmLazyRef,
                refererKey: thisLocal.refererKey,
                refererObj:
                    thisLocal.refererObj
                        && thisLocal.refererObj.constructor
                        && thisLocal.refererObj.constructor.name ?
                    thisLocal.refererObj.constructor.name
                    : null,
                "isLazyLoaded()": thisLocal.isLazyLoaded(),
                genericNode: thisLocal.genericNode? thisLocal.genericNode.toString(): null,
                signatureStr: thisLocal.signatureStr
            },
            null,
            2);
    }
}

/**
 * One-to-one.  
 * See {@link LazyRef}
 */
export declare type LazyRefOTM<L extends object> = LazyRef<L, undefined>;

/**
 * One-to-one.  
 * See {@link LazyRef}
 */
export declare type LazyRefMTO<L extends object, I> = LazyRef<L, I>;

/**
 * Default implementation!  
 * See {@link LazyRef}
 */
export class LazyRefDefault<L extends object, I> extends LazyRef<L, I> {

    private notificationStartTime: number = Date.now();
    private notificationCount: number = 0;

    private _instanceId: number;
	public get instanceId(): number {
		return this._instanceId;
	}
	public set instanceId(value: number) {
		this._instanceId = value;
	}

    private _hbId: I;
    private _lazyLoadedObj: L;
    private _genericNode: GenericNode;
    private _signatureStr: string;
    private _respObs: Observable<HttpResponse<Object>>;
    private _flatMapCallback: (response: HttpResponse<L>) => Observable<L>;
    private _refererObj: any;
    private _refererKey: string;
    private _session: IJsHbSession;

    constructor() {
        super();
        this._lazyLoadedObj = null;
    }

    private _isOnLazyLoading: boolean = false;

    public setLazyObjOnLazyLoading(lazyLoadedObj: L): void {
        try {
            this._isOnLazyLoading = true;
            this.setLazyObj(lazyLoadedObj);
        } finally {
            this._isOnLazyLoading = false;
        }
    }

    public isLazyLoaded(): boolean { 
        return this.respObs == null && this.lazyLoadedObj != null;
    };

    private _needCallNextOnSetLazyObj: boolean = true;

    private setLazyObjOnLazyLoadingNoNext(lazyLoadedObj: L) {
        try {
            this._needCallNextOnSetLazyObj = false;
            this.setLazyObjOnLazyLoading(lazyLoadedObj);
        } finally {
            this._needCallNextOnSetLazyObj = true;
        }
    }

    public setLazyObjNoNext(lazyLoadedObj: L) {
        try {
            this._needCallNextOnSetLazyObj = false;
            this.setLazyObj(lazyLoadedObj);
        } finally {
            this._needCallNextOnSetLazyObj = true;
        }
    }

    public notifyModification(lazyLoadedObj: L) : void {
        this.notificationCount++;
        let currentLazyRefNotificationTimeMeasurement = Date.now() - this.notificationStartTime;
        if (currentLazyRefNotificationTimeMeasurement > this.session.jsHbManager.jsHbConfig.lazyRefNotificationTimeMeasurement) {
            let speedPerSecond = (this.notificationCount / currentLazyRefNotificationTimeMeasurement) * 1000;
            if (speedPerSecond > this.session.jsHbManager.jsHbConfig.maxLazyRefNotificationPerSecond) {
                throw new Error('Max notications per second exceded: ' +
                    speedPerSecond + '. Are you modifing any persistent '+
                    'entity or collection on subscribe() instead of '+
                    'subscribeToModify() or '+
                    'is IJsHbConfig.maxLazyRefNotificationPerSecond, '+
                    this.session.jsHbManager.jsHbConfig.maxLazyRefNotificationPerSecond +
                    ', misconfigured? Me:\n' +
                    this);
            }
            this.notificationStartTime = Date.now();
            this.notificationCount = 0;
        }
        this.next(lazyLoadedObj);
    }

    private processResponseOnLazyLoading(responselike: { body: any }): L {
        try {
            this._isOnLazyLoading = true;
            return this.processResponse(responselike);
        } finally {
            this._isOnLazyLoading = false;
        }
    }

    public setLazyObj(lazyLoadedObj: L): void {
        //Validating
        if (!this.refererObj || !this.refererKey) {
            throw new Error('The property \'' + this.refererKey + ' has no refererObj or refererKey' + '. Me:\n' + this);
        }
        let prpGenType: GenericNode = GenericTokenizer.resolveNode(this.refererObj, this.refererKey);
        if (prpGenType == null) {
            throw new Error('The property \'' + this.refererKey + ' from \'' + this.refererObj.constructor.name + '\' is not decorated with com \'@Reflect.metadata("design:generics", GenericTokenizer\'...' + '. Me:\n' + this);
        }
        if (prpGenType.gType !== LazyRef) {
            throw new Error('The property \'' + this.refererKey + ' from \'' + this.refererObj.constructor.name + '\' is not LazyRef. Me:\n' + this);
        }
        let lazyRefGenericParam: Type<any> = null;
        if (prpGenType.gParams.length > 0) {
            if (prpGenType.gParams[0] instanceof GenericNode) {
                lazyRefGenericParam = (prpGenType.gParams[0] as GenericNode).gType;
            } else {
                lazyRefGenericParam = (prpGenType.gParams[0] as Type<any>);
            }
        }
        if ((lazyRefGenericParam === Set || lazyRefGenericParam === Array) && !this._isOnLazyLoading) {
            throw new Error('The property \'' + this.refererKey + ' from \'' + this.refererObj.constructor.name + '\' can not be changed because this is a collection: \'' + lazyRefGenericParam.name + '\'' + '. Me:\n' + this);
        }
        //null to response.
        this.respObs = null;

        if (!this.session.isOnRestoreEntireStateFromLiteral() && !this._isOnLazyLoading) {
            if (!this.session.isRecording()){
                throw new Error('Invalid operation. It is not recording. Is this Error correct?! Me:\n' + this);
            }
            if (this.lazyLoadedObj !== lazyLoadedObj) {
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.group('LazyRefDefault.setLazyObj()' +
                        '(this.lazyLoadedObj === lazyLoadedObj)\n' +
                        'NOT recording action: ' + JsHbPlaybackActionType.SetField + '. actual and new value: ');
                    console.debug(this.lazyLoadedObj);
                    console.debug(lazyLoadedObj);
                    console.groupEnd();
                }

                //recording playback
                let action: JsHbPlaybackAction = new JsHbPlaybackAction();
                action.fieldName = this.refererKey;
                action.actionType = JsHbPlaybackActionType.SetField;
                if (lodashHas(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName)) {
                    action.ownerSignatureStr = lodashGet(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName) as string;
                } else if (lodashHas(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbCreationIdName)) {
                    action.ownerCreationRefId = lodashGet(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbCreationIdName) as number;
                } else if (!this._isOnLazyLoading) {
                    throw new Error('The property \'' + this.refererKey + ' from \'' + this.refererObj.constructor.name + '\' has a not managed owner. Me:\n' + this);
                }

                if (lazyLoadedObj != null) {
                    if (lodashHas(lazyLoadedObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName)) {
                        action.settedSignatureStr = lodashGet(lazyLoadedObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName) as string;
                    } else if (lodashHas(lazyLoadedObj, this.session.jsHbManager.jsHbConfig.jsHbCreationIdName)) {
                        action.settedCreationRefId = lodashGet(lazyLoadedObj, this.session.jsHbManager.jsHbConfig.jsHbCreationIdName) as number;
                    } else if (!this._isOnLazyLoading) {
                        throw new Error('The property \'' + this.refererKey + ' from \'' + this.refererObj.constructor.name + '\'.  lazyLoadedObj is not managed: \'' + lazyLoadedObj.constructor.name + '\'' + '. Me:\n' + this);
                    }
                }

                this.session.addPlaybackAction(action);
            } else {
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.group('LazyRefDefault.setLazyObj()' +
                        '(this.lazyLoadedObj !== lazyLoadedObj)\n'+
                        'Recording action: ' + JsHbPlaybackActionType.SetField + '. value: ');
                    console.debug(lazyLoadedObj);
                    console.groupEnd();
                }
            }
        }

        if (this.lazyLoadedObj !== lazyLoadedObj) {
            if (this.lazyLoadedObj) {
                this.session.unregisterEntityAndLazyref(this.lazyLoadedObj, this);
            }
        }
        this._lazyLoadedObj = lazyLoadedObj;
        if (this.lazyLoadedObj) {
            this.session.registerEntityAndLazyref(this.lazyLoadedObj, this);
        }
        if (this._needCallNextOnSetLazyObj) {
            this.next(lazyLoadedObj);
            //this.session.notifyAllLazyrefsAboutEntityModification(this.lazyLoadedObj, this);
        }
    }

    subscribe(observerOrNext?: PartialObserver<L> | ((value: L) => void),
        error?: (error: any) => void,
        complete?: () => void): Subscription {
        const thisLocal = this;
        let resultSubs: Subscription = null;
        //here overwritten but nothing will happen because we have not done the next() yet
        if (observerOrNext instanceof Subscriber) {
            resultSubs = super.subscribe(observerOrNext);
        } else {
            resultSubs = super.subscribe(<(value: L) => void>observerOrNext, error, complete);
        }

        let nextModifierCallback: (value: L) => void = null;
        if (thisLocal.lazyLoadedObj == null) {
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.debug(
                    '(thisLocal.lazyLoadedObj == null)\n'
                    +'It may mean that we have not subscribed yet in the Observable of Response');
            }
            if (this.respObs == null) {
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug(
                        '(this.respObs == null)\n'
                        +'Means that we already subscribed to an earlier moment in the Observable of Reponse.\n'
                        +'We will simply call the super.subscribe');
                }
            } else if (this.session.getCachedBySignature(this.signatureStr)) {
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug(
                        '(this.lazyLoadedObj == null && this.respObs != null && this.session.getCachedBySignature(this.signatureStr)\n'
                        +'Means that we already loaded this object by signature with another lazyRef.\n'
                        +'We will get from session signature cache call next()');
                }
                thisLocal.respObs = null;
                thisLocal.setLazyObjOnLazyLoading(<L> this.session.getCachedBySignature(this.signatureStr));
                thisLocal.next(thisLocal.lazyLoadedObj);
            } else {
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug(
                        '(thisLocal.respObs != null)\n'
                        +'Means that we are not subscribed yet in the Observable of Reponse.\n'
                        +'this.respObs will be null after subscription, so we mark that '
                        +'there is already an inscription in the Response Observable, and we '+
                        'will not make two trips to the server');
                }
                let localObs: Observable<L> = 
                    thisLocal.respObs
                        .pipe(
                            flatMap(thisLocal.flatMapCallback)
                        );
                //assim marcaremos que ja ouve inscricao no Observable de response, e nao faremos duas idas ao servidor.
                thisLocal.respObs = null;

                let nextModifierNewCallback: PartialObserver<L> | ((value: L) => void) = null;
                if (observerOrNext instanceof Subscriber) {
                    nextModifierNewCallback = observerOrNext;
                    nextModifierCallback = (<Subscriber<L>>observerOrNext).next;
                    (<Subscriber<L>>observerOrNext).next = (value: L) => {
                        thisLocal.setLazyObjOnLazyLoading(value);
                        if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                            console.group('(Asynchronous) LazyRef.subscribe() => modifiedNext (thisLocal.respObs != null)');
                            console.debug('calling nextOriginal()'); console.debug('this.next()'); console.debug(thisLocal.lazyLoadedObj);
                            console.groupEnd();
                        }
                        nextModifierCallback(thisLocal.lazyLoadedObj);
                        //aqui o metodo original sera chamado
                        thisLocal.next(thisLocal.lazyLoadedObj);
                    };

                    //o retorno disso nunca mais sera usado
                    if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                        console.group('(thisLocal.respObs != null)');
                        console.debug('localObs.subscribe() <-- The Subscription returned here will never be used again.'); console.debug(nextModifierNewCallback);
                        console.groupEnd();
                    }
                    localObs.subscribe(nextModifierNewCallback);
                } else {
                    nextModifierCallback = <(value: L) => void>observerOrNext;
                    nextModifierNewCallback = (value: L) => {
                        if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                            console.group('(Asynchronous) LazyRef.subscribe() => observerOrNextNew, (thisLocal.respObs != null)');
                            console.debug('calling nextOriginal()'); console.debug('this.next()'); console.debug(thisLocal.lazyLoadedObj);
                            console.groupEnd();
                        }

                        thisLocal.setLazyObjOnLazyLoading(value);
                        nextModifierCallback(thisLocal.lazyLoadedObj);
                        //aqui o metodo original sera chamado
                        thisLocal.next(thisLocal.lazyLoadedObj);
                    };


                    //o retorno disso nunca mais sera usado
                    if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                        console.group('(thisLocal.respObs != null)');
                        console.debug('localObs.subscribe() <-- The Subscription returned here will never be used again.'); console.debug(nextModifierNewCallback); console.debug(error); console.debug(complete);
                        console.groupEnd();
                    }
                    localObs.subscribe(<(value: L) => void>nextModifierNewCallback, error, complete);
                }
            }
        } else {
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.debug(
                    '(thisLocal.lazyLoadedObj != null)\n'
                    +'It may mean that we already have subscribed yet in the Observable of Response\n '
                    +'or this was created with lazyLoadedObj already loaded.');
            }
            if (observerOrNext instanceof Subscriber) {
                nextModifierCallback = (<Subscriber<L>>observerOrNext).next;
                (<Subscriber<L>>observerOrNext).next = () => {
                    nextModifierCallback(thisLocal.lazyLoadedObj);
                };

                thisLocal.next(thisLocal.lazyLoadedObj);
            } else {
                nextModifierCallback = <(value: L) => void>observerOrNext;

                thisLocal.next(thisLocal.lazyLoadedObj);
            }
        }

        return resultSubs;
    }

    private subscriptionToChange: Subscription;

    private subscriptionToChangeUnsubscribe() {
        if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
            console.debug('LazyRefBase: unsubscribe after this.subscribeToChange. Me\n' + this);
        }
        this.subscriptionToChange.unsubscribe();
        this.session.notifyAllLazyrefsAboutEntityModification(this.lazyLoadedObj, this);
    }

    public processResponse(responselike: { body: any }): L {
        let literalJsHbResult: {result: any};
        let isLazyRefOfCollection = false;
        if (this.lazyLoadedObj == null) {
            literalJsHbResult = responselike.body;
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.debug('LazyRefBase.processResponse: LazyRef.lazyLoadedObj is not setted yet: Me:\n' + this);
            }
            //literal.result
            if (this.genericNode.gType !== LazyRef) {
                throw new Error('Wrong type: ' + this.genericNode.gType.name + '. Me:\n' + this);
            }
            let lazyLoadedObjType: Type<any> = null;
            if (this.genericNode.gParams[0] instanceof GenericNode) {
                lazyLoadedObjType = (<GenericNode>this.genericNode.gParams[0]).gType;
            } else {
                lazyLoadedObjType = <Type<any>>this.genericNode.gParams[0];
            }
            if (this.session.isCollection(lazyLoadedObjType)) {
                isLazyRefOfCollection = true;
                if (!(this.genericNode instanceof GenericNode) || (<GenericNode>this.genericNode.gParams[0]).gParams.length <=0) {
                    throw new Error('LazyRef not defined: \'' + this.refererKey + '\' of ' + this.refererObj.constructor.name + '. Me:\n' + this);
                }
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('LazyRefBase.processResponse: LazyRef is collection: ' + lazyLoadedObjType.name);
                }
                let collTypeParam: Type<any> =  null;
                if ((<GenericNode>this.genericNode.gParams[0]).gParams[0] instanceof GenericNode) {
                    collTypeParam = (<GenericNode>(<GenericNode>this.genericNode.gParams[0]).gParams[0]).gType;
                } else {
                    collTypeParam = <Type<any>>(<GenericNode>this.genericNode.gParams[0]).gParams[0];
                }
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('LazyRefBase.processResponse: LazyRef is collection of: ' + collTypeParam.name);
                }

                let lazyLoadedColl: any = this.session.createCollection(lazyLoadedObjType, this.refererObj, this.refererKey)
                lodashSet(lazyLoadedColl, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, true);
                try {
                    this.session.processJsHbResultEntityArrayInternal(collTypeParam, lazyLoadedColl, literalJsHbResult.result);
                    this.setLazyObjOnLazyLoadingNoNext(lazyLoadedColl);
                } finally {
                    lodashSet(this.lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, false);
                }
            } else {
                this.setLazyObjOnLazyLoadingNoNext(this.session.processJsHbResultEntityInternal(lazyLoadedObjType, literalJsHbResult.result));
                //was the only way I found to undock the Observable<L> from the Observable<Response>
                //  The side effect of this is that map() called before this exchange is
                //  not piped with new Observable.
            }
        }
        if (this.signatureStr) {
            if (!this.session.isOnRestoreEntireStateFromLiteral()) {
                if (!lodashHas(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName)) {
                    throw new Error('The referer object has no '+ this.session.jsHbManager.jsHbConfig.jsHbSignatureName + ' key. This should not happen. Me:\n' + this);
                } else {
                    //this.refererObj is a component.
                    if (isLazyRefOfCollection) {

                    }
                }
                let ownerSignatureStr = lodashGet(this.refererObj, this.session.jsHbManager.jsHbConfig.jsHbSignatureName);
                if (!ownerSignatureStr) {
                    if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                        console.debug('LazyRefBase.processResponse: (!ownerSignatureStr): owner entity not found for LazyRef, the owner must be a hibernate component. Me:\n' + this);
                    }
                }
                let thisLocal = this;
                this.session.storeOriginalLiteralEntry(
                    {
                        method: 'lazyRef',
                        ownerSignatureStr: ownerSignatureStr,
                        ownerFieldName: this.refererKey,
                        literalJsHbResult: literalJsHbResult,
                        ref: {
                            iAmAJsHbEntityRef: true,
                            signatureStr: thisLocal.signatureStr
                        }
                    }
                );
            }
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.group('LazyRefBase.processResponse: keeping reference by signature ' + this.signatureStr);
                console.debug(this.lazyLoadedObj);
                console.groupEnd();
            }
            this.session.tryCacheInstanceBySignature(
                {
                    realInstance: this.lazyLoadedObj,
                    literalJsHbResult: literalJsHbResult,
                    lazySignature: this.signatureStr
                }
            );
        }
        if (this.respObs && this.session.isOnRestoreEntireStateFromLiteral()) {
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.group('LazyRefBase.processResponse: changing "this.respObs"'+
                    ' to null because "this.session.isOnRestoreEntireStateFromLiteral()"\n' + this);
                console.debug(this.lazyLoadedObj);
                console.groupEnd();
            }
            this.respObs = null;
        }
        return this.lazyLoadedObj;
    }

    subscribeToModify(observerOrNext?: PartialObserver<L> | ((value: L) => void),
        error?: (error: any) => void,
        complete?: () => void) {
        const thisLocal = this;

        let nextModifierCallback: (value: L) => void = null;

        let nextModifierNewCallback: PartialObserver<L> | ((value: L) => void) = null;
        if (!this.isLazyLoaded()) { //isso sim significa que ainda nao foi carregado.
            //AAAAASYNCHRONOUS!!!
            if (observerOrNext instanceof Subscriber) {
                nextModifierNewCallback = observerOrNext;
                nextModifierCallback = (<Subscriber<L>>observerOrNext).next;
                (<Subscriber<L>>observerOrNext).next = (value: L) => {
                    if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                        console.group('(Asynchronous) LazyRef.subscribeToChange() => modifiedNext, (thisLocal.respObs != null)');
                        console.debug('calling nextOriginal()'); console.debug('this.subscriptionToChange.unsubscribe()'); console.debug('this.next()\n' + this); console.debug(thisLocal.lazyLoadedObj);
                        console.groupEnd();
                    }
                    thisLocal.setLazyObjOnLazyLoadingNoNext(value);
                    //propety set and collection add will call session.notifyAllLazyrefsAboutEntityModification()
                    // this will cause infinit recursion, so call session.switchOffNotifyAllLazyrefs
                    thisLocal.session.switchOffNotifyAllLazyrefs(thisLocal.lazyLoadedObj);
                    //call that will change the data Asynchronously
                    nextModifierCallback(thisLocal.lazyLoadedObj);
                    //no more problems with infinite recursion
                    thisLocal.session.switchOnNotifyAllLazyrefs(thisLocal.lazyLoadedObj);

                    //this ensures that the change command will not be called twice.
                    this.subscriptionToChangeUnsubscribe();
                    //here all other previous subscribes will be called. Pipe async's for example
                    thisLocal.next(thisLocal.lazyLoadedObj);
                };
                if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('Keeping Subscription from this.subscribe(observerOrNextNovo) on this.subscriptionToChange to make an unsubscribe() at the end of modifiedNext callback\n' + this);
                }
                this.subscriptionToChange = this.subscribe(nextModifierNewCallback);
            } else {
                nextModifierCallback = <(value: L) => void>observerOrNext;
                nextModifierNewCallback = (value: L) => {
                    //isso garante que o comando de alteracao nao sera chamado duas vezes.
                    thisLocal.subscriptionToChangeUnsubscribe();
                    thisLocal.setLazyObjOnLazyLoadingNoNext(value);
                    //propety set and collection add will call session.notifyAllLazyrefsAboutEntityModification()
                    // this will cause infinit recursion, so call session.switchOffNotifyAllLazyrefs
                    thisLocal.session.switchOffNotifyAllLazyrefs(thisLocal.lazyLoadedObj);
                    //call that will change the data Asynchronously
                    nextModifierCallback(thisLocal.lazyLoadedObj);
                    //no more problems with infinite recursion
                    thisLocal.session.switchOnNotifyAllLazyrefs(thisLocal.lazyLoadedObj);

                    //aqui todos os outros subscribes anteriores serao chamados. Os pipe async's por exemplo
                    thisLocal.next(thisLocal.lazyLoadedObj);
                };
                this.subscriptionToChange = this.subscribe(<(value: L) => void>nextModifierNewCallback, error, complete);
            }
        } else {
            //SSSSSYNCHRONOUS!!!
            if (JsHbLogLevel.Trace >= this.session.jsHbManager.jsHbConfig.logLevel) {
                console.group('(Synchronous) LazyRef.subscribeToChange()');
                console.debug('calling nextOriginal()'); console.debug('this.next()\n' + this);;
                console.groupEnd();
            }
            if (observerOrNext instanceof Subscriber) {
                nextModifierNewCallback = observerOrNext;
                nextModifierCallback = (<Subscriber<L>>observerOrNext).next;
                //chamada que ira alterar os dados Sincronamente
                nextModifierCallback(thisLocal.lazyLoadedObj);
                //aqui todos os outros observer's anteriores serao chamados. Os pipe async's por exemplo
                thisLocal.next(thisLocal.lazyLoadedObj);
            } else {
                nextModifierCallback = <(value: L) => void>observerOrNext;
                //chamada que ira alterar os dados Sincronamente
                nextModifierCallback(thisLocal.lazyLoadedObj);
                //aqui todos os outros observer's anteriores serao chamados. Os pipe async's por exemplo
                thisLocal.next(thisLocal.lazyLoadedObj);
            }
        }
    }
    public get hbId(): I {
        return this._hbId;
    }
    public get lazyLoadedObj(): L {
        return this._lazyLoadedObj;
    }
    public get signatureStr(): string {
        return this._signatureStr;
    }
    public set hbId(value: I) {
        this._hbId = value;
    }
    public set signatureStr(value: string) {
        this._signatureStr = value;
    }
    public get respObs(): Observable<HttpResponse<Object>> {
        return this._respObs;
    }
    public set respObs(value: Observable<HttpResponse<Object>>) {
        this._respObs = value;
    }

    private set flatMapCallback(value: (response: HttpResponse<L>) => Observable<L>) {
        this._flatMapCallback = value;
    }

    private get flatMapCallback(): (response: HttpResponse<L>) => Observable<L> {
        if (!this._flatMapCallback) {
            this._flatMapCallback = (response) => {
                let lReturn = this.processResponseOnLazyLoading(response);
                return observableOf(lReturn);
            };
        }
        return this._flatMapCallback;
    }
    
	public get refererObj(): any {
		return this._refererObj;
	}
	public set refererObj(value: any) {
		this._refererObj = value;
	}
	public get refererKey(): string {
		return this._refererKey;
	}
	public set refererKey(value: string) {
		this._refererKey = value;
    }
	public get session(): IJsHbSession {
		return this._session;
	}
	public set session(value: IJsHbSession) {
		this._session = value;
    }
    public get genericNode(): GenericNode {
		return this._genericNode;
	}
	public set genericNode(value: GenericNode) {
		this._genericNode = value;
	}    
}