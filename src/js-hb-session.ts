import { GenericNode, GenericTokenizer } from './generic-tokenizer';
import { LazyRef,  LazyRefDefault, LazyRefPrpMarker} from './lazy-ref';
import { IJsHbManager, JsHbManagerDefault } from './js-hb-manager';
import { Type } from '@angular/core';
import { catchError, map, flatMap, delay, finalize, mapTo } from 'rxjs/operators';
import { MergeWithCustomizer } from 'lodash';
import { throwError, Observable, of, OperatorFunction, combineLatest, concat, pipe } from 'rxjs';
import { JsHbContants } from './js-hb-constants';
import { JsHbPlayback } from './js-hb-playback';
import { JsHbPlaybackAction, JsHbPlaybackActionType } from './js-hb-playback-action';
import { JsHbSetCreator } from './js-hb-set-creator';
import { JSONHelper } from './json-helper';
import { JsHbLogLevel, FieldInfo } from './js-hb-config';
import { set as lodashSet, get as lodashGet, has as lodashHas, mergeWith as lodashMergeWith, keys as lodashKeys, clone as lodashClone } from 'lodash';
import { NgJsHbDecorators } from './js-hb-decorators';
import { JsHbBackendMetadatas } from './js-hb-backend-metadatas';
import { LazyInfo } from './js-hb-http-lazy-observable-gen';
import { IFieldProcessor } from './field-processor';
import { Stream } from 'stream';
import { v1 as uuidv1} from 'uuid';
import { FieldEtc, IFieldProcessorCaller } from './field-etc';

export interface JsHbEntityRef {
    iAmAJsHbEntityRef: boolean;
    signatureStr?: string;
    creationId?: number;
}

/** Framework internal use. */
export interface OriginalLiteralValueEntry {
    method: 'processJsHbResultEntity' | 'processJsHbResultEntityArray' | 'newEntityInstance' | 'lazyRef';
    reflectFunctionMetadataTypeKey?: string;
    ownerSignatureStr?: string;
    ownerFieldName?: string;
    literalJsHbResult?: {result: any};
    attachRefId?: string;
    ref?: JsHbEntityRef;
}

interface JsHbSessionState {
    sessionId: string;
    nextCreationId: number;
    originalLiteralValueEntries: Array<OriginalLiteralValueEntry>
    latestPlaybackArrAsLiteral: Array<any>;
    currentJsHbPlaybackAsLiteral?: any;
}

declare type prptype = any;

/**
 * Contract
 */
export interface IJsHbSession {
    /**
     * Manager.
     */
    jsHbManager: IJsHbManager;
    /**
     * Process the response body literal object getted from backend.  
     * Body format: { result: any }.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * it call {@link #storeOriginalLiteralEntry)} for a future {@link this#restoreEntireStateFromLiteral}.  
     * @param entityType - Type<L>
     * @param literalJsHbResult a literal object with format { result: any }
     */
    processJsHbResultEntity<L>(entityType: Type<L>, literalJsHbResult: {result: any}): Observable<L>;
    /**
     * Process the response body literal for each object getted from backend.  
     * Body format: \{ result: Array<any> \}.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the L instance.  
     * It call {@link this#storeOriginalLiteralEntry} for a future {@link this#restoreEntireStateFromLiteral}.  
     *
     * @param entityType - Type<L>
     * @param literalJsHbResult - \{result: any\}
     * @returns Array<L>
     */
    processJsHbResultEntityArray<L>(entityType: Type<L>, literalJsHbResult: {result: any}): Observable<Array<L>>;
    /**
     * Generate a managed instance for type T.  
     * Creates all the {@link ./lazy-ref#LazyRef} and {@link ./lazy-ref#LazyRefOTM} for the T instance.
     * 
     * @param entityType - \{Type<T>\} 
     * @returns T
     */
    newEntityInstance<T extends object>(entityType: Type<T>): Observable<T>;
    /**
     * Start recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedPlayback}  
     * See: {@link this#getLastRecordedPlaybackAsLiteral}
     */
    startRecording(): void;
    /**
     * Stop recording for all modifications on entity objects returned.  
     * See: {@link this#getLastRecordedPlayback}  
     * See: {@link this#getLastRecordedPlaybackAsLiteral}
     */
    stopRecording(): void;
    /**
     * Generate recoverable JSONParsable literal object that can be used
     * on {@link this#restoreEntireStateFromLiteral} to restore the session
     * state including all cached entity instance and all modifications.
     *
     * @returns recoverable JSONParsable literal object
     */
    generateEntireStateAsLiteral(): Observable<any>;
    /**
     * Restore the session state using the object state generated by
     * {@link this#getEntireStateAsLiteral}.
     *
     * @param {*} literalState
     */
    restoreEntireStateFromLiteral(literalState: any):  Observable<void>;
    /** Framework internal use. */
    isOnRestoreEntireStateFromLiteral(): boolean;
    /** Framework internal use. */
    keepAllFlagsRxOpr<T, A>(lazyLoadedObj: any, mapCallback: (srcValue: T) => A): OperatorFunction<T, A>;
    //keepAllFlagsRxOpr<T, A>(lazyLoadedObj: any, originalOp: OperatorFunction<T, A>): OperatorFunction<T, A>;
    // /** Framework internal use. */
    // keepIsOnRestoreRxOpr<T, A>(originalOp: OperatorFunction<T, A>): OperatorFunction<T, A>;
    /**
     * Creates a recoverable JSONParsable literal object that can be used
     * after {@link this#restoreEntireStateFromLiteral} on
     * {@link this#getEntityInstanceFromLiteralRef}.
     *
     * @param realEntity - T
     */
    createLiteralRefForEntity<T>(realEntity: T): any;
    /**
     * Get the managed instance for literalRef  
     * 
     * See:  
     * {@link this#generateEntireStateAsLiteral}  
     * {@link this#restoreEntireStateFromLiteral}  
     * {@link this#createLiteralRefForEntity}  
     *
     * @param literalRef - any
     * @returns
     */
    getEntityInstanceFromLiteralRef<T>(literalRef: any): T;
    /**
     * Get all recorded modifications between last calls for {@link this#startRecording} 
     * and {@link this#stopRecording}.
     *
     * @returns {JsHbPlayback}
     */
    getLastRecordedPlayback(): Observable<JsHbPlayback>;
    getLastRecordedStreams(): Observable<Map<String, Stream>>;
    getLastRecordedPlaybackAndStreams(): Observable<{playback: JsHbPlayback, streams: Map<String, Stream>}>;
    /**
     * Equivalent to {@link this#getLastRecordedPlayback} with recoverable
     * JSONParsable literal object return.
     *
     * @returns
     */
    getLastRecordedPlaybackAsLiteral(): Observable<any>;
    getLastRecordedPlaybackAsLiteralAndStreams(): Observable<{playbackLiteral: any, streams: Map<String, Stream>}>;
    /** Framework internal use. */
    getCachedBySignature<T extends object>(signatureStr: string): T;
    /** Framework internal use. */
    addPlaybackAction(action: JsHbPlaybackAction): void;
    /** Framework internal use. */
    isRecording(): boolean;
    /**
     * Record action equivalente to 'org.hibernate.Session.save()'.
     *
     * @param entity - 
     */
    recordSave(entity: any): void;
    /**
     * Record action equivalente to 'org.hibernate.Session.delete()'.
     *
     * @param entity -
     */
    recordDelete(entity: any): void;
    /** Framework internal use. */
    storeOriginalLiteralEntry(originalValueEntry: OriginalLiteralValueEntry): void;
    /** Framework internal use. */
    tryCacheInstanceBySignature(
        tryOptions:
            {
                realInstance: any,
                literalJsHbResult: {result: any},
                lazySignature?: string
            }): void;
    /**
     * Framework internal use.
     */
    processJsHbResultEntityInternal<L>(entityType: Type<L>, literalResultField: any): Observable<L>;
    /**
     * Framework internal use.
     */
    processJsHbResultEntityArrayInternal<L>(entityType: Type<L>, lazyLoadedColl: any, literalResultField: any[]): Observable<void>;
    /**
     * Clear/release all data for the session including cached e modifications recorded.
     */
    clear(): void;
    /**
     * Framework internal use.
     */
    createApropriatedLazyRef<L extends object, I>(genericNode: GenericNode, literalLazyObj: any, refererObj: any, refererKey: string): LazyRef<L, I>;
    /** Framework internal use.  Collection utility. */
    createCollection(collType: Type<any>, refererObj: any, refererKey: string): any;
    /** Framework internal use.  Collection utility. */
    isCollection(typeTested: Type<any>): any;
    /** Framework internal use.  Collection utility. */
    addOnCollection(collection: any, element: any): void;
    /** Framework internal use.  Collection utility. */
    removeFromCollection(collection: any, element: any): void;
    /** Framework internal use. */
    registerEntityAndLazyref(entity: object, lazyRef: LazyRef<any, any>): void;
    /** Framework internal use. */
    unregisterEntityAndLazyref(entity: object, lazyRef: LazyRef<any, any>): void;
    /** Framework internal use. */
    nextMultiPurposeInstanceId(): number;
    /** Framework internal use. */
    notifyAllLazyrefsAboutEntityModification(entity: object, lazyRef: LazyRef<any, any>): void;
    /**
     * Switch off the the modifying notification for this entity.  
     * Each entity property set trigger {@link LazyRef#next} for all related 
     * {@link LazyRef}, so this can introduce some script over processing,
     * this method is a workaround for this problem.
     * 
     * @param entity 
     */
    switchOffNotifyAllLazyrefs(entity: object): void;
    /**
     * Switch on the the modifying notification for this entity.  
     * Calls {@link this#notifyAllLazyrefsAboutEntityModification}.  
     * See {@link this#switchOffNotifyAllLazyrefs}.
     * @param entity 
     */
    switchOnNotifyAllLazyrefs(entity: object): void;

    getLastRecordedAtaches(): Map<String, Stream>;
    /** Framework internal use. */
    recordAtache(attach: Stream): string;
    /** Framework internal use. */
    fielEtcCacheMap: Map<Object, Map<String, FieldEtc<any, any>>>;
    
    // /** Framework internal use. All framework internal subscribe() is stored here.*/
    // addSubscribedObservableForWaiting<T>(obs: Observable<T>): Observable<T>;
    /** Framework internal use. All framework internal subscribe() is stored here.*/
    addSubscribedObservable<T>(): OperatorFunction<T, T>;
    /**
     * Generate an Observable for waiting all internal async task.  
     * Use it be notified about completion of all inernal async tasks.
     */
    createAsyncTasksWaiting(): Observable<void>;
    /**
     * Generate an Observable for waiting all internal async task.  
     * Each observable is just started after before.  
     * Use it be notified about completion of all inernal async tasks.
     */
    createSerialAsyncTasksWaiting(): Observable<void>;
    /** Framework internal use. */
    resolveMetadatas(
        options: 
            {
                object?: any,
                literalObject?: any,
                key?: string,
                refererObject?: Object,
                refererLiteralObject?: any
            }) :
            {
                refererObjMD?: JsHbBackendMetadatas,
                objectMD?: JsHbBackendMetadatas,
                hibernateIdMD?: JsHbBackendMetadatas
            };
}

export class JsHbSessionDefault implements IJsHbSession {
    private _objectsBySignature: Map<string, any> = null;
    private _objectsByCreationId: Map<number, any> = null;
    private _lazyrefsByEntityMap: Map<object, Set<LazyRef<any, any>>> = null;
    private _fielEtcCacheMap: Map<Object, Map<String, FieldEtc<any, any>>> = null;

	get fielEtcCacheMap(): Map<Object, Map<String, FieldEtc<any, any>>>  {
		return this._fielEtcCacheMap;
	}

    private _switchedOffNotificationEntitiesSet: Set<object> = null;
    private _originalLiteralValueEntries: Array<OriginalLiteralValueEntry> = null;
    private _nextCreationId: number = null;
    private _currentJsHbPlayback: JsHbPlayback = null;
    private _latestJsHbPlayback: Array<JsHbPlayback> = null;
    private _currentRecordedAtaches: Map<String, Stream> = null;
    private _latestRecordedAtaches: Map<String, String | Stream> = null;
    private _isOnRestoreEntireStateFromLiteral = false;
    private _sessionId: string;
    private _asyncTasksWaitingArr: Set<Observable<any>> = new Set();

    addSubscribedObservable<T>(): OperatorFunction<T, T> {
        let thisLocal = this;
        const resultOpr: OperatorFunction<T, T> = (source: Observable<any>) => {
            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                (source as any).jsHbTraceId = 'addSubscribedObservable_' + this.nextMultiPurposeInstanceId();
                console.debug('addSubscribedObservable(). source Observable jsHbTraceId: ' + (source as any).jsHbTraceId);
            }
            const isDone = { value: false };
            const result$ = source.pipe(
                map((value) => {
                    if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                        (source as any).jsHbTraceId = 'addSubscribedObservable_' + thisLocal.nextMultiPurposeInstanceId();
                        console.debug('addSubscribedObservable(). source => pipe(). source Observable jsHbTraceId: ' + (source as any).jsHbTraceId);
                        console.debug('addSubscribedObservable(). source => pipe(). result$ Observable jsHbTraceId: ' + (result$ as any).jsHbTraceId);
                    }
                    isDone.value = true;
                    thisLocal._asyncTasksWaitingArr.delete(result$);
                    return value;
                })
            );
            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                (result$ as any).jsHbTraceId = 'addSubscribedObservable_' + thisLocal.nextMultiPurposeInstanceId();
                console.trace('addSubscribedObservable(). result$ Observable jsHbTraceId: ' + (result$ as any).jsHbTraceId);
            }
            // new Observable<T>(observer => {
            //     return source.subscribe({
            //         next(srcValue) {

            //         },
            //         error(err) { observer.error(err); },
            //         complete() { observer.complete(); }
            //     });
            // });
            if (!isDone.value) {
                thisLocal._asyncTasksWaitingArr.add(result$);
            }
            return result$;
        }

        // const resultOpr: OperatorFunction<T, T> = (source) => {
        //     //for sync observable
        //     const isDone = { value: false };
        //     let result$ =
        //         source
        //             // .pipe(
        //             //     catchError((err, caught) => {
        //             //         console.error(err);
        //             //         return caught;
        //             //     })
        //             // )
        //             .pipe(
        //                 map((srcValue)=> {
        //                     isDone.value = true;
        //                     this._asyncTasksWaitingArr.delete(source);
        //                     return srcValue;
        //                 })
        //             );
        //     if (!isDone.value) {
        //         this._asyncTasksWaitingArr.add(result$);
        //     }
        //     return result$;
        // }

        return resultOpr;
    }

    // addSubscribedObservableForWaiting<T>(obs: Observable<T>): Observable<T> {
    //     const thisLocal = this;
    //     //for sync observable
    //     const isDone = {value: false};
    //     const result$ =
    //         obs.pipe(
    //             map((value) => {
    //                 isDone.value = true;
    //                 thisLocal._asyncTasksWaitingArr.delete(result$);
    //                 return value;
    //             })
    //         );
    //     if (!isDone.value) {
    //         thisLocal._asyncTasksWaitingArr.add(result$);
    //     }
    //     return result$;
    // }

    createAsyncTasksWaiting(): Observable<void> {
        if (this._asyncTasksWaitingArr.size > 0) {
            return combineLatest(Array.from(this._asyncTasksWaitingArr))
                .pipe(
                    map((value)=>{
                        console.log('generateAsyncTasksWaiting -> map: ' + value);
                    })
                );
        } else {
            return of(null);
        }
    }

    createSerialAsyncTasksWaiting(): Observable<void> {
        if (this._asyncTasksWaitingArr.size > 0) {
            let serialResult$: Observable<void> = of(null);
            for (const item$ of Array.from(this._asyncTasksWaitingArr)) {
                serialResult$ = serialResult$.pipe(
                    flatMap(() => {
                        return item$;
                    })
                );
            }
            return serialResult$;
        } else {
            return of(null);
        }
    }

    constructor(private _jsHbManager: IJsHbManager) {
		if (!_jsHbManager) {
			throw new Error('_jsHbManager can not be null');
        }
        if (JsHbLogLevel.Debug >= _jsHbManager.jsHbConfig.logLevel) {
            console.group('JsHbSessionDefault.constructor');
			console.debug(_jsHbManager as any as string);
            console.groupEnd();
		}
        this._objectsBySignature = new Map();
        this._objectsByCreationId = new Map();
        this._lazyrefsByEntityMap = new Map();
        this._fielEtcCacheMap = new Map();
        this._switchedOffNotificationEntitiesSet = new Set();
        this._originalLiteralValueEntries = [];
        this._latestJsHbPlayback = [];
        this._sessionId = uuidv1();
    }

    public generateEntireStateAsLiteral(): Observable<any> {
        const thisLocal = this;
        return this.createAsyncTasksWaiting()
            .pipe(
                map(() => {
                    let jsHbSessionState: JsHbSessionState = {
                        sessionId: this._sessionId,
                        nextCreationId: thisLocal._nextCreationId,
                        latestPlaybackArrAsLiteral: [],
                        originalLiteralValueEntries: thisLocal._originalLiteralValueEntries
                    };
            
                    for (const playbackItem of thisLocal._latestJsHbPlayback) {
                        jsHbSessionState.latestPlaybackArrAsLiteral.push(thisLocal.getPlaybackAsLiteral(playbackItem));
                    }
                    if (thisLocal._currentJsHbPlayback) {
                        jsHbSessionState.currentJsHbPlaybackAsLiteral = thisLocal.getPlaybackAsLiteral(thisLocal._currentJsHbPlayback);
                    }
            
                    return jsHbSessionState;
                })
            );
    }

    private restoreEntireStateCallbackTemplate<R>(callback: () => R): R {
        this._isOnRestoreEntireStateFromLiteral = true;
        try {
            return callback();
        } finally {
            this._isOnRestoreEntireStateFromLiteral = false;
        }
    }

    public restoreEntireStateFromLiteral(literalState: any): Observable<void> {
        const thisLocal = this;
        return this.restoreEntireStateCallbackTemplate(() => {
            let lazyRefProcessResponseArr: Observable<any>[] = [];
            let literalStateLocal: JsHbSessionState = literalState;
            thisLocal._nextCreationId = literalStateLocal.nextCreationId;
            thisLocal._originalLiteralValueEntries = literalStateLocal.originalLiteralValueEntries;
            if (literalStateLocal.currentJsHbPlaybackAsLiteral) {
                thisLocal._currentJsHbPlayback = thisLocal.getPlaybackFromLiteral(literalStateLocal.currentJsHbPlaybackAsLiteral);
            } else {
                thisLocal._currentJsHbPlayback = null;
            }
            this._latestJsHbPlayback = [];
            for (const playbackLiteral of literalStateLocal.latestPlaybackArrAsLiteral) {
                thisLocal._latestJsHbPlayback.push(thisLocal.getPlaybackFromLiteral(playbackLiteral));
            }
            let originalLiteralValueEntriesLengthInitial: number = thisLocal._originalLiteralValueEntries.length;
            for (const originalLiteralValueEntry of thisLocal._originalLiteralValueEntries) {
                if (originalLiteralValueEntriesLengthInitial !== thisLocal._originalLiteralValueEntries.length) {
                    throw new Error('There is some error on "this.storeOriginalLiteralEntry()"'+
                        ' manipulation. Initial length ' +originalLiteralValueEntriesLengthInitial+
                        ' is differrent of actual ' + thisLocal._originalLiteralValueEntries.length);
                }
                if (originalLiteralValueEntry.method === 'processJsHbResultEntity'
                        || originalLiteralValueEntry.method === 'processJsHbResultEntityArray'
                        || originalLiteralValueEntry.method === 'newEntityInstance') {
                    let jsType: Type<any> = Reflect.getMetadata(originalLiteralValueEntry.reflectFunctionMetadataTypeKey, Function);
                    if (!jsType) {
                        throw new Error('the classe \'' + originalLiteralValueEntry.reflectFunctionMetadataTypeKey + ' is not using the decorator \'NgJsHbDecorators.clazz\'. Entry:\n' + JSON.stringify(originalLiteralValueEntry, null, 2));
                    }
                    if (originalLiteralValueEntry.method === 'processJsHbResultEntity') {
                        lazyRefProcessResponseArr.push(thisLocal.processJsHbResultEntity(jsType, originalLiteralValueEntry.literalJsHbResult));
                    } else if (originalLiteralValueEntry.method === 'processJsHbResultEntityArray') {
                        lazyRefProcessResponseArr.push(thisLocal.processJsHbResultEntityArray(jsType, originalLiteralValueEntry.literalJsHbResult));
                    } else if (originalLiteralValueEntry.method === 'newEntityInstance') {
                        lazyRefProcessResponseArr.push(thisLocal.newEntityInstanceWithCreationId(jsType, originalLiteralValueEntry.ref.creationId));
                    } else {
                        throw new Error('This should not happen');
                    }
                } else if (originalLiteralValueEntry.method === 'lazyRef') {
                    originalLiteralValueEntry.ownerSignatureStr
                    if (originalLiteralValueEntry.ownerSignatureStr) {
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.debug('JsHbSessionDefault.restoreEntireStateFromLiteral: (ownerSignatureStr): ownerSignatureStr found for original literal value entry, the owner must be a hibernate component. Entry:\n' + JSON.stringify(originalLiteralValueEntry, null, 2));
                        }
                        let ownerEnt = this._objectsBySignature.get(originalLiteralValueEntry.ownerSignatureStr);
                        if (!ownerEnt) {
                            throw new Error('ownerEnt not found for signature: ' + originalLiteralValueEntry.ownerSignatureStr);                 
                        }
                        let lazyRef: LazyRef<any, any> = lodashGet(ownerEnt, originalLiteralValueEntry.ownerFieldName);
                        if (!lazyRef) {
                            throw new Error('ownerEnt has no field: ' + originalLiteralValueEntry.ownerFieldName);
                        }
                        if (!lazyRef.iAmLazyRef) {
                            throw new Error(originalLiteralValueEntry.ownerFieldName + ' is not a LazyRef for ' + ownerEnt);    
                        }
                        lazyRefProcessResponseArr.push(
                            lazyRef.processResponse({ body: originalLiteralValueEntry.literalJsHbResult })
                        );
                    } else {
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.debug('JsHbSessionDefault.restoreEntireStateFromLiteral: (!ownerEnt): '+
                                'No owner entity for original literal value entry, the owner must be a\n'+
                                'hibernate component. Doing nothing, in any next literal value entry\n'+
                                'there will exist an action with type \'processJsHbResultEntity\' that will\n'+
                                'put the entity on cache. Entry:\n' +
                                JSON.stringify(originalLiteralValueEntry, null, 2));
                        }
                    }
                } else {
                    throw new Error('This should not happen');
                }
            }

            let combineLatest$: Observable<any[]>;
            if (lazyRefProcessResponseArr.length > 0) {
                combineLatest$ = combineLatest(lazyRefProcessResponseArr);
            } else {
                combineLatest$ = of([]);
            }
            // forkJoinResult$ = this.addSubscribedObservableForWaiting(forkJoinResult$);
            // combineLatest$ = combineLatest$.pipe(thisLocal.addSubscribedObservable());
            return combineLatest$.pipe(
                flatMap( () => {
                    return thisLocal.rerunByPlaybacksIgnoreCreateInstance();
                })
             );
        });
    }

    public isOnRestoreEntireStateFromLiteral(): boolean {
        return this._isOnRestoreEntireStateFromLiteral;
    }

    private keepAllFlagsCallbackCreate<T>(lazyLoadedObj: any): (originalCb: () => T|void) => T|void {
        const thisLocal = this;
        const syncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
        const syncIsOn2 = this._isOnRestoreEntireStateFromLiteral;
        return (originalCb: () => T) => {
            const asyncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
            const asyncIsOn2 = thisLocal._isOnRestoreEntireStateFromLiteral;
            lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, syncIsOn);
            thisLocal._isOnRestoreEntireStateFromLiteral = syncIsOn2;
            try {
                return originalCb();
            } finally {
                lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, asyncIsOn);
                thisLocal._isOnRestoreEntireStateFromLiteral = asyncIsOn2;
            }
        }
    }

    keepAllFlagsRxOpr<T, A>(lazyLoadedObj: any, mapCallback: (srcValue: T) => A): OperatorFunction<T, A> {
        const thisLocal = this;
        const syncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
        const syncIsOn2 = this._isOnRestoreEntireStateFromLiteral;
        let newOp: OperatorFunction<T, A> = (source) => {
            return source
                .pipe(
                    map((srcValue) => {
                        const asyncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
                        const asyncIsOn2 = thisLocal._isOnRestoreEntireStateFromLiteral;
                        lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, syncIsOn);
                        thisLocal._isOnRestoreEntireStateFromLiteral = syncIsOn2;
                        try {
                            return mapCallback(srcValue);
                        } finally {
                            lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, asyncIsOn);
                            thisLocal._isOnRestoreEntireStateFromLiteral = asyncIsOn2;
                        }
                    })
                );
        }

        return newOp;
    }

    // keepAllFlagsRxOpr<T, A>(lazyLoadedObj: any, originalOp: OperatorFunction<T, A>): OperatorFunction<T, A> {
    //     const syncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
    //     const syncIsOn2 = this._isOnRestoreEntireStateFromLiteral;
    //     let newOp: OperatorFunction<T, A> = (source) => {
    //         return originalOp(source)
    //             .pipe(
    //                 map((srcValue) => {
    //                     const asyncIsOn = lodashGet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME);
    //                     const asyncIsOn2 = this._isOnRestoreEntireStateFromLiteral;
    //                     lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, syncIsOn);
    //                     this._isOnRestoreEntireStateFromLiteral = syncIsOn2;
    //                     try {
    //                         return srcValue;
    //                     } finally {
    //                         lodashSet(lazyLoadedObj, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, asyncIsOn);
    //                         this._isOnRestoreEntireStateFromLiteral = asyncIsOn2;
    //                     }
    //                 })
    //             );
    //     }

    //     return newOp;
    // }

    // //?!?!?!?!?!
    // keepIsOnRestoreRxOpr<T, A>(originalOp: OperatorFunction<T, A>): OperatorFunction<T, A> {
    //     const syncIsOn = this._isOnRestoreEntireStateFromLiteral;
    //     let newOp: OperatorFunction<T, A> = (source) => {
    //         const asyncIsOn = this._isOnRestoreEntireStateFromLiteral;
    //         this._isOnRestoreEntireStateFromLiteral = syncIsOn;
    //         try {
    //             return originalOp(source);
    //         } finally {
    //             this._isOnRestoreEntireStateFromLiteral = asyncIsOn;
    //         }
    //     }

    //     return newOp;
    // }

    /**
     * Based on '[JsHbPlaybackAction.java].resolveOwnerValue(IJsHbManager, HashMap<Long, Object>)'
     * @param action 
     */
    private actionResolveOwnerValue(action: JsHbPlaybackAction): any {
        if (action.ownerSignatureStr) {
            return this._objectsBySignature.get(action.ownerSignatureStr);
        } else if (action.ownerCreationId) {
            throw new Error('This should not happen. Action: ' + action.actionType);
        } else if (action.ownerCreationRefId) {
            return this._objectsByCreationId.get(action.ownerCreationRefId);
        } else {
            throw new Error('This should not happen. Action: ' + JSON.stringify(action));
        }
    }

    /**
     * Based on '[JsHbPlaybackAction.java].resolveJavaPropertyName(ObjectMapper, IJsHbManager, HashMap<Long, Object>)'
     * @param action 
     */
    private actionResolveFieldName(action: JsHbPlaybackAction): any {
        return action.fieldName;
    }

    /**
     * Based on '[JsHbPlaybackAction.java].resolveColletion(ObjectMapper, IJsHbManager, HashMap<Long, Object>)'
     * @param action 
     */
    private actionResolveColletion(action: JsHbPlaybackAction): any {
		if (action.actionType == JsHbPlaybackActionType.CollectionAdd || action.actionType == JsHbPlaybackActionType.CollectionRemove) {
			try {
				return this.actionResolveOwnerValue(action)[this.actionResolveFieldName(action)];
			} catch (e) {
                let newErr: any = new Error('This should not happen. action. Action ' + JSON.stringify(action));
                newErr.reason = e;
                throw newErr;
			}
		} else {
            return null;
        }
    }



    /**
     * Based on '[JsHbPlaybackAction.java].resolveSettedValue(ObjectMapper, IJsHbManager, HashMap<Long, Object>)'
     * @param action 
     */
    private actionResolveSettedValue<P, GP>(action: JsHbPlaybackAction, fieldEtc: FieldEtc<P, GP>): Observable<P> {
        const thisLocal = this;
        let resolvedSettedValue$: Observable<P>;

        if (action.settedCreationRefId) {
            resolvedSettedValue$ = of(this._objectsByCreationId.get(action.settedCreationRefId) as P);
        } else if (fieldEtc.lazyRefGenericParam === LazyRefPrpMarker){
            if(action.simpleSettedValue) {
                if(fieldEtc.fieldProcessorCaller.callFromLiteralValue) {
                    resolvedSettedValue$ = fieldEtc.fieldProcessorCaller.callFromLiteralValue(
                        action.simpleSettedValue,
                        fieldEtc.fieldInfo);
                }
            } else if (action.attachRefId) {
                if (fieldEtc.fieldProcessorCaller.callFromDirectRaw) {
                    //fieldEtc.fieldProcessorCaller.callFromDirectRaw()
                    //resolvedSettedValue$ = 
                    resolvedSettedValue$ = thisLocal.jsHbManager.jsHbConfig.cacheHandler.getFromCache(action.attachRefId)
                        .pipe(
                            flatMap((stream) => {
                                return fieldEtc.fieldProcessorCaller.callFromDirectRaw(stream, fieldEtc.fieldInfo);
                            })
                        );
                } else {
                    resolvedSettedValue$ = thisLocal.jsHbManager.jsHbConfig.cacheHandler.getFromCache(action.attachRefId) as any as Observable<P>;
                }
            } else {
                throw new Error('Invalid action. LazyRefPrp invalid values: ' + JSON.stringify(action));                
            }
        } else if (action.settedSignatureStr) {
            resolvedSettedValue$ = of(thisLocal._objectsBySignature.get(action.settedSignatureStr) as P);
        } else if (action.fieldName) {
            resolvedSettedValue$ = of(action.simpleSettedValue as P);
        }
        // resolvedSettedValue$ = this.addSubscribedObservableForWaiting(resolvedSettedValue$);
        resolvedSettedValue$ = resolvedSettedValue$.pipe(thisLocal.addSubscribedObservable());
        return resolvedSettedValue$;
    }
    /**
     * Based on '[JsHbReplayable.java].replay()'
     */
    private rerunByPlaybacksIgnoreCreateInstance(): Observable<void> {
        const thisLocal = this;
        let obsArr: Observable<void>[] = [];
        let allPlaybacks: JsHbPlayback[] = [
            ...this._latestJsHbPlayback.slice(),
            ...(this._currentJsHbPlayback? [this._currentJsHbPlayback]: [])
        ];
        for (const playback of allPlaybacks) {
            for (const action of playback.actions) {
                if (action.actionType != JsHbPlaybackActionType.Create) {
                    let resolvedOwnerValue: any = thisLocal.actionResolveOwnerValue(action);
                    let resolvedFieldName: string = thisLocal.actionResolveFieldName(action);
                    let resolvedCollection: any = thisLocal.actionResolveColletion(action);
                    let fieldEtc = JsHbManagerDefault.resolveFieldProcessorPropOptsEtc(
                        thisLocal.fielEtcCacheMap,
                        resolvedOwnerValue, resolvedFieldName,
                        thisLocal.jsHbManager.jsHbConfig);
                    let resolvedSettedValue$: Observable<any> = thisLocal.actionResolveSettedValue(action, fieldEtc);

                    obsArr.push(resolvedSettedValue$.pipe(map((value) => {})));
                    //result$ = new Subject<void>();

                    // resolvedSettedValue$ = this.addSubscribedObservableForWaiting(resolvedSettedValue$);
                    resolvedSettedValue$ = resolvedSettedValue$.pipe(thisLocal.addSubscribedObservable());
                    resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                        thisLocal.restoreEntireStateCallbackTemplate(()=> {
                            const wasCollectionAsyncronousModified = { value: true };
                            switch (action.actionType) {
                                case JsHbPlaybackActionType.CollectionAdd:
                                    if (resolvedCollection && (resolvedCollection as LazyRef<any, any>).iAmLazyRef) {
                                        //em tese isso deve ser sincrono por ja estar
                                        //this.addAsyncTaskWaiting(resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>);
                                        (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>)
                                            .subscribeToModify(coll => {
                                                thisLocal.addOnCollection(coll, resolvedSettedValue);
                                                wasCollectionAsyncronousModified.value = false;
                                            });
                                    } else {
                                        thisLocal.addOnCollection(resolvedCollection, resolvedSettedValue);
                                        wasCollectionAsyncronousModified.value = false;
                                    }
                                    if (wasCollectionAsyncronousModified.value) {
                                        throw new Error('Invalid action. Collection was not loaded on current state: ' + JSON.stringify(action));
                                    }
                                    break;
                                case JsHbPlaybackActionType.CollectionRemove:
                                    if (resolvedCollection && (resolvedCollection as LazyRef<any, any>).iAmLazyRef) {
                                        //em tese isso deve ser sincrono por ja estar
                                        //this.addAsyncTaskWaiting(resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>);
                                        (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>)
                                            .subscribeToModify(coll => {
                                                thisLocal.restoreEntireStateCallbackTemplate(()=> {
                                                    thisLocal.removeFromCollection(coll, resolvedSettedValue);
                                                })
                                                wasCollectionAsyncronousModified.value = false;
                                            });
                                    } else {
                                        thisLocal.restoreEntireStateCallbackTemplate(()=> {
                                            thisLocal.removeFromCollection(resolvedCollection, resolvedSettedValue);
                                        })
                                        wasCollectionAsyncronousModified.value = false;
                                    }
                                    if (wasCollectionAsyncronousModified.value) {
                                        throw new Error('Invalid action. Collection was not loaded on current state: ' + JSON.stringify(action));
                                    }
                                    break;
                                case JsHbPlaybackActionType.SetField:
                                    if (resolvedOwnerValue[resolvedFieldName] && (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>).iAmLazyRef) {
                                        let setLazyObjNoNext$ = (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>).setLazyObjNoNext(resolvedSettedValue);
                                        // setLazyObjNoNext$ = this.addSubscribedObservableForWaiting(setLazyObjNoNext$);
                                        setLazyObjNoNext$ = setLazyObjNoNext$.pipe(thisLocal.addSubscribedObservable());
                                        setLazyObjNoNext$.subscribe(() => {});
                                    } else {
                                        thisLocal.restoreEntireStateCallbackTemplate(()=> {
                                            resolvedOwnerValue[resolvedFieldName] = resolvedSettedValue;
                                        });
                                    }
                                    break;
                                case JsHbPlaybackActionType.Delete:
                                    //nada
                                    break;
                                case JsHbPlaybackActionType.Save:
                                    //nada
                                    break;
                                default:
                                    throw new Error('This should not happen');
                            }
                        })
                    });




                    // const wasCollectionAsyncronousModified = { value: true };
                    // switch (action.actionType) {
                    //     case JsHbPlaybackActionType.CollectionAdd:
                    //         if (resolvedCollection && (resolvedCollection as LazyRef<any, any>).iAmLazyRef) {
                    //             //em tese isso deve ser sincrono por ja estar
                    //             (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>)
                    //                 .subscribeToModify(coll => {
                    //                     this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //                     resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                         this.restoreEntireStateCallbackTemplate(()=> {
                    //                             this.addOnCollection(coll, resolvedSettedValue);
                    //                         })
                    //                     });
                    //                     wasCollectionAsyncronousModified.value = false;
                    //                 });
                    //         } else {
                    //             this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //             resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                 this.restoreEntireStateCallbackTemplate(()=> {
                    //                     this.addOnCollection(resolvedCollection, resolvedSettedValue);
                    //                 })
                    //             });
                    //             wasCollectionAsyncronousModified.value = false;
                    //         }
                    //         if (wasCollectionAsyncronousModified.value) {
                    //             throw new Error('Invalid action. Collection was not loaded on current state: ' + JSON.stringify(action));
                    //         }
                    //         break;
                    //     case JsHbPlaybackActionType.CollectionRemove:
                    //         if (resolvedCollection && (resolvedCollection as LazyRef<any, any>).iAmLazyRef) {
                    //             //em tese isso deve ser sincrono por ja estar
                    //             (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>)
                    //                 .subscribeToModify(coll => {
                    //                     this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //                     resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                         this.restoreEntireStateCallbackTemplate(()=> {
                    //                             this.removeFromCollection(coll, resolvedSettedValue);
                    //                         })
                    //                     });
                    //                     wasCollectionAsyncronousModified.value = false;
                    //                 });
                    //         } else {
                    //             this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //             resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                 this.restoreEntireStateCallbackTemplate(()=> {
                    //                     this.removeFromCollection(resolvedCollection, resolvedSettedValue);
                    //                 })
                    //             });
                    //             wasCollectionAsyncronousModified.value = false;
                    //         }
                    //         if (wasCollectionAsyncronousModified.value) {
                    //             throw new Error('Invalid action. Collection was not loaded on current state: ' + JSON.stringify(action));
                    //         }
                    //         break;
                    //     case JsHbPlaybackActionType.SetField:
                    //         if (resolvedOwnerValue[resolvedFieldName] && (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>).iAmLazyRef) {
                    //             this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //             resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                 this.restoreEntireStateCallbackTemplate(()=> {
                    //                     (resolvedOwnerValue[resolvedFieldName] as LazyRef<any, any>).setLazyObjNoNext(resolvedSettedValue);
                    //                 })
                    //             });
                    //         } else {
                    //             this.addAsyncTaskWaiting(resolvedSettedValue$);
                    //             resolvedSettedValue$.subscribe((resolvedSettedValue) => {
                    //                 this.restoreEntireStateCallbackTemplate(()=> {
                    //                     resolvedOwnerValue[resolvedFieldName] = resolvedSettedValue;
                    //                 })
                    //             });
                    //         }
                    //         break;
                    //     case JsHbPlaybackActionType.Delete:
                    //         //nada
                    //         break;
                    //     case JsHbPlaybackActionType.Save:
                    //         //nada
                    //         break;
                    //     default:
                    //         throw new Error('This should not happen');
                    // }
                }
            }
        }
        let combineLatestResult$: Observable<void>;
        if (obsArr.length > 0) {
            combineLatestResult$ = combineLatest(obsArr).pipe(map(() => {}));
        } else {
            combineLatestResult$ = of(null);
        }
        //this.addAsyncTaskWaiting(forkJoinResult$);
        return combineLatestResult$;
    }

    resolveMetadatas(
            options: 
                {
                    object?: any,
                    literalObject?: any,
                    key?: string,
                    refererObject?: Object,
                    refererLiteralObject?: any
                }) :
                {
                    refererObjMD?: JsHbBackendMetadatas,
                    objectMD?: JsHbBackendMetadatas,
                    hibernateIdMD?: JsHbBackendMetadatas,
                    refererObjMDFound: boolean,
                    objectMDFound: boolean,
                    hibernateIdMDFound: boolean
                } {
        let valueOrliteral = options.object || options.literalObject || {};
        let refererObjectOrLiteral = options.refererObject || options.refererLiteralObject || {};
        
        let refererObjMD: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        let objectMD: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        let hibernateIdMD: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        let refererObjMDFound: boolean = false;
        let objectMDFound: boolean = false;
        let hibernateIdMDFound: boolean = false;

        if (lodashHas(valueOrliteral, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            objectMDFound =true;
            objectMD = lodashGet(valueOrliteral, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        }
        if (lodashHas(refererObjectOrLiteral, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            refererObjMDFound = true;
            refererObjMD = lodashGet(refererObjectOrLiteral, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        }
        //we are processing the metadata
        if (options.key === this.jsHbManager.jsHbConfig.jsHbMetadatasName 
                && (valueOrliteral as JsHbBackendMetadatas).$iAmJsHbBackendMetadatas$
                && lodashHas((valueOrliteral as JsHbBackendMetadatas).$hibernateId$, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            if (lodashHas((valueOrliteral as JsHbBackendMetadatas).$hibernateId$, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
                hibernateIdMDFound = true;
                hibernateIdMD = lodashGet((valueOrliteral as JsHbBackendMetadatas).$hibernateId$, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
            }
        }
        return {
            refererObjMD: refererObjMD,
            objectMD: objectMD,
            hibernateIdMD: hibernateIdMD,
            refererObjMDFound: refererObjMDFound,
            objectMDFound: objectMDFound,
            hibernateIdMDFound: hibernateIdMDFound
        };
    }

    public createLiteralRefForEntity<T>(realEntity: T): any {
        if (!realEntity) {
            throw new Error('realEntity can not be null');
        }
        let allMD = this.resolveMetadatas({ object: realEntity });
        let jsHbEntityRefReturn: JsHbEntityRef;
        let backendMetadatas: JsHbBackendMetadatas = allMD.objectMD;

        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(realEntity, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(realEntity, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        //if (lodashHas(realEntity, this.jsHbManager.jsHbConfig.jsHbSignatureName)) {
        if (backendMetadatas.$signature$) {
            jsHbEntityRefReturn = {
                //signatureStr: lodashGet(realEntity, this.jsHbManager.jsHbConfig.jsHbSignatureName),
                signatureStr: backendMetadatas.$signature$,
                iAmAJsHbEntityRef: true
            }
        } else if (lodashHas(realEntity, this.jsHbManager.jsHbConfig.jsHbCreationIdName)) {
            jsHbEntityRefReturn = {
                creationId: lodashGet(realEntity, this.jsHbManager.jsHbConfig.jsHbCreationIdName),
                iAmAJsHbEntityRef: true
            }
        } else {
            throw new Error('Invalid operation. Not managed entity. Entity: \'' + realEntity.constructor + '\'');
        }
        return jsHbEntityRefReturn;
    }

    public getEntityInstanceFromLiteralRef<T>(literalRef: any): T {
        let jsHbEntityRef: JsHbEntityRef = literalRef;
        if (jsHbEntityRef.iAmAJsHbEntityRef && jsHbEntityRef.signatureStr) {
            return this._objectsBySignature.get(jsHbEntityRef.signatureStr);
        } else if (jsHbEntityRef.iAmAJsHbEntityRef && jsHbEntityRef.creationId) {
            return this._objectsByCreationId.get(jsHbEntityRef.creationId);
        } else {
            throw new Error('Invalid operation. Not managed entity. literalRef: \'' + literalRef + '\'');
        }
    }

    /**
     * Getter jsHbManager
     * @return {IJsHbManager}
     */
    public get jsHbManager(): IJsHbManager {
        return this._jsHbManager;
    }

    /**
     * Setter jsHbManager
     * @param {IJsHbManager} value
     */
    public set jsHbManager(value: IJsHbManager) {
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('JsHbSessionDefault.jsHbManager set');
			console.debug(value as any as string);
            console.groupEnd();
		}
        this._jsHbManager = value;
    }

    public processJsHbResultEntity<L>(entityType: Type<L>, literalJsHbResult: {result: any}): Observable<L> {
        let resultL$: Observable<L>;

        if (!literalJsHbResult.result) {
            throw new Error('literalJsHbResult.result existe' + JSON.stringify(literalJsHbResult));
        }
        let clazzOptions: NgJsHbDecorators.clazzOptions = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_JAVA_CLASS, entityType);
        if (!clazzOptions) {
            throw new Error('the classe \'' + entityType + ' is not using the decorator \'NgJsHbDecorators.clazz\'');
        }

        let allMD = this.resolveMetadatas({literalObject: literalJsHbResult});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalJsHbResult.result, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(literalJsHbResult.result, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }

        if (!this.isOnRestoreEntireStateFromLiteral()) {
            //let jsHbIsComponent: boolean = lodashGet(literalJsHbResult, this.jsHbManager.jsHbConfig.jsHbIsAssociativeName);            
            if (!backendMetadatas.$isComponent$) {
                this.storeOriginalLiteralEntry(
                    {
                        method: 'processJsHbResultEntity',
                        reflectFunctionMetadataTypeKey: NgJsHbDecorators.mountContructorByJavaClassMetadataKey(clazzOptions, entityType),
                        literalJsHbResult: literalJsHbResult
                    });
            }
        }
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('JsHbSessionDefault.processJsHbResultEntity<L>()');
            console.debug(entityType); console.debug(literalJsHbResult);
            console.groupEnd();
        }
        let refMap: Map<Number, any> = new Map<Number, any>();
        resultL$ = this.processJsHbResultEntityPriv(entityType, literalJsHbResult.result, refMap);
        resultL$.pipe(
            map((resultL) => {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.group('JsHbSessionDefault.processJsHbResultEntity<L>() => result$.pipe(). resultL:');
                    console.debug(resultL);
                    console.groupEnd();
                }
                return resultL;
            })
        );
        // if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
        //     console.group('JsHbSessionDefault.processJsHbResultEntity<L>().  result:');
        //     console.debug(result);
        //     console.groupEnd();
        // }

        return resultL$;
    }

    public processJsHbResultEntityArray<L>(entityType: Type<L>, literalJsHbResult: {result: any}): Observable<Array<L>> {
        if (!literalJsHbResult.result) {
            throw new Error('literalJsHbResult.result existe' + JSON.stringify(literalJsHbResult));
        }
        let clazzOptions: NgJsHbDecorators.clazzOptions = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_JAVA_CLASS, entityType);
        if (!clazzOptions) {
            throw new Error('the classe \'' + entityType + ' is not using the decorator \'NgJsHbDecorators.clazz\'');
        }
        if (!this.isOnRestoreEntireStateFromLiteral()) {
            this.storeOriginalLiteralEntry(
                {
                    method: 'processJsHbResultEntityArray',
                    reflectFunctionMetadataTypeKey: NgJsHbDecorators.mountContructorByJavaClassMetadataKey(clazzOptions, entityType),
                    literalJsHbResult: literalJsHbResult
                });
        }

        let resultObsArr: Observable<L>[] = [];
        let refMap: Map<Number, any> = new Map<Number, any>();
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('JsHbSessionDefault.processJsHbResultEntityArray<L>()');
            console.debug(entityType); console.debug(literalJsHbResult);
            console.groupEnd();
        }
        for (let index = 0; index < literalJsHbResult.result.length; index++) {
            const resultElement = literalJsHbResult.result[index];
            resultObsArr.push(this.processJsHbResultEntityPriv(entityType, resultElement, refMap));
        }
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('JsHbSessionDefault.processJsHbResultEntityArray<L>(). result:');
            console.debug(resultObsArr);
            console.groupEnd();
        }
        return combineLatest(resultObsArr);
        // concat(...resultObsArr).subscribe((value) => {  })
        // return concat(...resultObsArr).subscribe((value) => {});
    }

    private newEntityInstanceWithCreationId<T extends object>(entityType: Type<T>, creationId: number): Observable<T> {
        let resultT$: Observable<T>;
        if (!this.isOnRestoreEntireStateFromLiteral() && !this.isRecording()){
            throw new Error('Invalid operation. It is not recording. is this Error correct?!');
        }
        this.validatingMetaFieldsExistence(entityType);
        let entityObj = new entityType();
        lodashSet(entityObj, JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME, this);
        let realKeys: string[] = Object.keys(Object.getPrototypeOf(entityObj));
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.debug('entityType: ' + entityType.name);
        }
        for (let index = 0; index < realKeys.length; index++) {
            const keyItem = realKeys[index];
            let prpGenType: GenericNode = GenericTokenizer.resolveNode(entityObj, keyItem);
            if (!prpGenType) {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('GenericNode not found for property key \'' + keyItem + '\' of ' + entityType.name);
                }
            } else if (prpGenType.gType !== LazyRef) {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('GenericNode found but it is not a LazyRef. Property key \'' + keyItem + '\' of ' + entityType.name);
                }
            } else {
                let lazyRefGenericParam: Type<any> = null;
                if (prpGenType.gParams.length > 0) {
                    if (prpGenType.gParams[0] instanceof GenericNode) {
                        lazyRefGenericParam = (prpGenType.gParams[0] as GenericNode).gType;
                    } else {
                        lazyRefGenericParam = (prpGenType.gParams[0] as Type<any>);
                    }

                    if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                        console.debug('GenericNode found and it is a LazyRef, lazyRefGenericParam: ' + lazyRefGenericParam.name + ' . Property key \'' + keyItem + '\' of ' + entityType.name);
                    }

                    let allMD = this.resolveMetadatas({refererObject: entityObj, key: keyItem});
                    if (this.isCollection(lazyRefGenericParam)) {
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.debug('GenericNode found, it is a LazyRef, and it is a Collection, lazyRefGenericParam: ' + lazyRefGenericParam.name + ' . Property key \'' + keyItem + '\' of ' + entityType.name);
                        }
                        let lazyRefSet: LazyRefDefault<any, any> = new LazyRefDefault<any, any>();
                        let setLazyObjOnLazyLoading$ = lazyRefSet.setLazyObjOnLazyLoading(this.createCollection(lazyRefGenericParam, entityObj, keyItem));
                        setLazyObjOnLazyLoading$ = setLazyObjOnLazyLoading$.pipe(this.addSubscribedObservable());
                        setLazyObjOnLazyLoading$.subscribe(
                            {
                                next: () => {}
                            }
                        );

                        //BE CAREFULL HERE!!!!!!!!!!!!!!!!!!!!!!!!
                        lazyRefSet.instanceId = this.nextMultiPurposeInstanceId();

                        lazyRefSet.refererObj = entityObj;
                        lazyRefSet.refererKey = keyItem;
                        lazyRefSet.session = this;
                        lazyRefSet.backendMetadatasLazyLoadedObj = allMD.objectMD;
                        lazyRefSet.backendMetadatasRefererObj = allMD.refererObjMD;
                        lazyRefSet.backendMetadatasHibernateIdMetadata = allMD.hibernateIdMD;
                        lodashSet(entityObj, keyItem, lazyRefSet);
                    } else {
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.debug('GenericNode found, it is a LazyRef, and it is not a Collection, lazyRefGenericParam: ' + lazyRefGenericParam.name + ' . Property key \'' + keyItem + '\' of ' + entityType.name);
                        }
                        let lazyRef: LazyRefDefault<any, any> = new LazyRefDefault<any, any>();
                        lazyRef.instanceId = this.nextMultiPurposeInstanceId();
                        lazyRef.refererObj = entityObj;
                        lazyRef.refererKey = keyItem;
                        lazyRef.session = this;
                        lazyRef.backendMetadatasLazyLoadedObj = allMD.objectMD;
                        lazyRef.backendMetadatasRefererObj = allMD.refererObjMD;
                        lazyRef.backendMetadatasHibernateIdMetadata = allMD.hibernateIdMD;
                        lodashSet(entityObj, keyItem, lazyRef);
                    }
                } else {
                    throw new Error('Property \'' + keyItem + ' of \'' + entityObj.constructor + '\'. LazyRef not properly defined on Reflect');
                }
            }
        }

        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.debug('isRecording, ');
        }

        this._objectsByCreationId.set(creationId, entityObj);
        let clazzOptions: NgJsHbDecorators.clazzOptions = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_JAVA_CLASS, entityType);
        if (!clazzOptions) {
            throw new Error('the classe \'' + entityType + ' is not using the decorator \'NgJsHbDecorators.clazz\'');
        }
        if (!this.isOnRestoreEntireStateFromLiteral()) {    
            this.storeOriginalLiteralEntry(
                {
                    method: 'newEntityInstance',
                    reflectFunctionMetadataTypeKey: NgJsHbDecorators.mountContructorByJavaClassMetadataKey(clazzOptions, entityType),
                    ref: {
                        creationId: creationId,
                        iAmAJsHbEntityRef: true
                    }
                });
        }
        
        lodashSet(entityObj, this.jsHbManager.jsHbConfig.jsHbCreationIdName, creationId);
        lodashSet(entityObj, JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME, this);

        if (!this.isOnRestoreEntireStateFromLiteral()) {
            //gravando o playback
            let action: JsHbPlaybackAction = new JsHbPlaybackAction();
            action.fieldName = null;
            action.actionType = JsHbPlaybackActionType.Create;
            
            let clazzOptions: NgJsHbDecorators.clazzOptions = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_JAVA_CLASS, entityType);
            if (!clazzOptions) {
                throw new Error('the classe \'' + entityType + ' is not using the decorator \'NgJsHbDecorators.clazz\'');
            }
            action.ownerJavaClass = clazzOptions.javaClass;
            action.ownerCreationId = this._nextCreationId;
            this.addPlaybackAction(action);
        }

        return this.createAsyncTasksWaiting()
            .pipe(
                map(() => {
                    return entityObj;
                })
            );
    }

    public newEntityInstance<T extends object>(entityType: Type<T>): Observable<T> {
        if (!this.isRecording()){
            throw new Error('Invalid operation. It is not recording.');
        }

        let newEntityInstanceWithCreationId$ = this.newEntityInstanceWithCreationId<T>(entityType, this._nextCreationId);
        return newEntityInstanceWithCreationId$
            .pipe(
                map((newEntityReturn) => {
                    this._nextCreationId++;
                    return newEntityReturn;
                })
            );

        // let newEntityReturn: T = 
        // this._nextCreationId++;
        // return newEntityReturn;
    }

    public startRecording(): void {
        if (this.isRecording()) {
            throw new Error('I am already recording!');
        }
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.debug('reseting this._currentJsHbPlayback, this._objectsCreationId and this._nextCreationId');
        }
        this._currentJsHbPlayback = new JsHbPlayback();
        this._nextCreationId = 1;
    }

    public stopRecording(): void {
        if (this.isRecording()) {
            if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
                console.debug('updating this.lastJsHbPlayback and resetting this.currentJsHbPlayback');
            }
            this._latestJsHbPlayback.push(this._currentJsHbPlayback);
            this._currentJsHbPlayback = null;
        } else {
            throw new Error('I am not recording!');
        }
    }
    
    public recordSave(entity: any): void {
        if (!entity){
            throw new Error('entity can not be null');
        }
        if (!this.isRecording()){
            throw new Error('Invalid operation. It is not recording. entity: \'' + entity.constructor.name + '\'. Is this Error correct?!');
        }
        let session: IJsHbSession = lodashGet(entity, JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME) as IJsHbSession;
        if (!session) {
            throw new Error('Invalid operation. \'' + entity.constructor.name + '\' not managed. \'' + JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME + '\' estah null');
        } else if (session !== this) {
            throw new Error('Invalid operation. \'' + entity.constructor.name + '\' managed by another session.');
        }
        let allMD = this.resolveMetadatas({object: entity});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(entity, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }

        //gravando o playback
        let action: JsHbPlaybackAction = new JsHbPlaybackAction();
        action.actionType = JsHbPlaybackActionType.Save;
        //if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbSignatureName)) {
        if (backendMetadatas.$signature$) {
            throw new Error('Invalid operation. \'' + entity.constructor + '\' has a signature, that is, it has persisted');
        } else if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbCreationIdName)) {
            action.ownerCreationRefId = lodashGet(entity, this.jsHbManager.jsHbConfig.jsHbCreationIdName) as number;
        } else {
            throw new Error('Invalid operation. Not managed entity. Entity: \'' + entity.constructor + '\'');
        }
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('action: ');
            console.debug(action);
            console.groupEnd();
        }
        this.addPlaybackAction(action);
    }

    public recordDelete(entity: any): void {
        if (!entity){
            throw new Error('Entity nao pode ser nula');
        }
        if (!this.isRecording()){
            throw new Error('Invalid operation. It is not recording. entity: \'' + entity.constructor.name + '\'. Is this Error correct?!');
        }
        let session: IJsHbSession = lodashGet(entity, JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME) as IJsHbSession;
        if (!session) {
            throw new Error('Invalid operation. \'' + entity.constructor + '\' not managed. \'' + JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME + '\' estah null');
        } else if (session !== this) {
            throw new Error('Invalid operation. \'' + entity.constructor + '\' managed by another session.');
        }
        let allMD = this.resolveMetadatas({object: entity});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(entity, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        //gravando o playback
        let action: JsHbPlaybackAction = new JsHbPlaybackAction();
        action.actionType = JsHbPlaybackActionType.Delete;
        //if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbSignatureName)) {
        if (backendMetadatas.$signature$) {
            //action.ownerSignatureStr = lodashGet(entity, this.jsHbManager.jsHbConfig.jsHbSignatureName) as string;
            action.ownerSignatureStr = backendMetadatas.$signature$;
        } else if (lodashHas(entity, this.jsHbManager.jsHbConfig.jsHbCreationIdName)) {
            throw new Error('Invalid operation. \'' + entity.constructor + '\' has id of creation, that is, is not persisted.');
        } else {
            throw new Error('Invalid operation. Not managed entity. Entity: \'' + entity.constructor + '\'');
        }
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.debug('action: ' + action);
        }
        this.addPlaybackAction(action);
    }

    recordAtache(attach: Stream): string {
        let name = this.jsHbManager.jsHbConfig.attachPrefix + this.nextMultiPurposeInstanceId();
        this._currentRecordedAtaches.set(name, attach);
        return name;
    }

    public storeOriginalLiteralEntry(originalValueEntry: OriginalLiteralValueEntry): void {
        this._originalLiteralValueEntries.push(originalValueEntry);
    }

    public clear(): void {
        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
            console.debug('clearing: this.objectsBySignature, this.objectsCreationId, this.nextCreationId, this.currentJsHbPlayback, this.lastJsHbPlayback and this.objectsBySignature');
        }
        this._nextCreationId = null;
        this._currentJsHbPlayback = null;
        this._latestJsHbPlayback = null;
        this._nextMultiPurposeInstanceId = 1;
        this._objectsBySignature = new Map();
        this._objectsByCreationId = new Map();
        this._lazyrefsByEntityMap = new Map();
        this._fielEtcCacheMap = new Map();
        this._switchedOffNotificationEntitiesSet = new Set();
        this._originalLiteralValueEntries = [];
        this._latestJsHbPlayback = [];
        
        let clearCache$: Observable<void> = this.jsHbManager.jsHbConfig.cacheHandler.clearCache();
        clearCache$ = clearCache$.pipe(this.addSubscribedObservable());
        clearCache$.subscribe(() => {});
    }

    getLastRecordedPlayback(): Observable<JsHbPlayback> {
        const thisLocal = this;
        return this.createAsyncTasksWaiting().pipe(map(() => {
            return thisLocal._latestJsHbPlayback.length > 0? thisLocal._latestJsHbPlayback[thisLocal._latestJsHbPlayback.length - 1] : null;
        }));
    }

    getLastRecordedStreams(): Observable<Map<String, Stream>> {
        const thisLocal = this;
        return this.getLastRecordedPlayback()
            .pipe(
                flatMap((playback) => {
                    const idAndStreamObsArr: Observable<{attachRefId: String, stream: Stream}>[] = [];
                    if (playback && playback.actions){
                        for (const actionItem of playback.actions) {
                            if (actionItem.attachRefId) {
                                let idAndStream$: Observable<{attachRefId: String, stream: Stream}> = 
                                    thisLocal.jsHbManager.jsHbConfig.cacheHandler.getFromCache(actionItem.attachRefId)
                                        .pipe(
                                            map((streamValue) => {
                                                return {
                                                    attachRefId: actionItem.attachRefId,
                                                    stream: streamValue
                                                }
                                            })
                                        );
                                idAndStreamObsArr.push(idAndStream$);
                            }
                        }
                        if (idAndStreamObsArr.length > 0) {
                            return combineLatest(idAndStreamObsArr);
                        } else {
                            return of([]);
                        }
                    } else {
                        return of([]);
                    }
                })
            )
            .pipe(
                map((idAndStreamArr) => {
                    const resultMap: Map<String, Stream> = new Map();
                    for (const idAndStreamItem of idAndStreamArr) {
                        resultMap.set(idAndStreamItem.attachRefId, idAndStreamItem.stream);
                    }
                    return resultMap;
                })
            );
    }

    getLastRecordedPlaybackAndStreams(): Observable<{playback: JsHbPlayback, streams: Map<String, Stream>}> {
        const thisLocal = this;
        return this.getLastRecordedPlayback()
            .pipe(
                flatMap((playback) => {
                    return thisLocal.getLastRecordedStreams()
                        .pipe(
                            map((streamsMap) => {
                                return {
                                    playback: playback,
                                    streams: streamsMap
                                }
                            })
                        );
                })
            );
    }

    getLastRecordedPlaybackAsLiteralAndStreams(): Observable<{playbackLiteral: any, streams: Map<String, Stream>}> {
        const thisLocal = this;
        return this.getLastRecordedPlaybackAsLiteral()
            .pipe(
                flatMap((playbackLiteral) => {
                    return this.getLastRecordedStreams()
                        .pipe(
                            map((streamsMap) => {
                                return {
                                    playbackLiteral: playbackLiteral,
                                    streams: streamsMap
                                }
                            })
                        );
                })
            );
    }

    public addPlaybackAction(action: JsHbPlaybackAction): void {
        if (!this.isRecording()) {
            throw new Error('The recording is not started!');
        }
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('addPlaybackAction');
            console.debug(action as any as string);
            console.groupEnd();
        }

        this._currentJsHbPlayback.actions.push(action);
    }

    public isRecording(): boolean {
        return (this._currentJsHbPlayback != null);
    }

    public getLastRecordedPlaybackAsLiteral(): Observable<any> {
        const thisLocal = this;
        const result$: Observable<any> = this.getLastRecordedPlayback()
            .pipe(
                map((playback) => {
                    let resultLit =  thisLocal.getPlaybackAsLiteral(playback);
                    if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
                        console.group('getLastRecordedPlaybackAsLiteral');
                        console.debug(resultLit as any as string);
                        console.groupEnd();
                    }
                    return resultLit;
                })
            );
        return result$;
    }

    getLastRecordedAtaches(): Map<String, Stream> {
        return new Map(this._currentRecordedAtaches);
    }

    private getPlaybackAsLiteral(playback: JsHbPlayback): any {
        const literalReturn: any = JSONHelper.convertToLiteralObject(playback, true)
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('getPlaybackAsLiteral');
            console.debug(literalReturn as any as string);
            console.groupEnd();
        }
        return literalReturn;
    }

    private getPlaybackFromLiteral(playbackLiteral: any): JsHbPlayback {
        const playBackReturn: JsHbPlayback = new JsHbPlayback();
        playBackReturn.actions = [];
        for (const actionLiteral of playbackLiteral.actions) {
            let action: JsHbPlaybackAction = new JsHbPlaybackAction();
            action = lodashMergeWith(
                action, 
                actionLiteral, 
                (value: any, srcValue: any) => {
                    return srcValue;
                }
            );
            playBackReturn.actions.push(action);
        }
        if (JsHbLogLevel.Debug >= this.jsHbManager.jsHbConfig.logLevel) {
            console.group('getPlaybackFromLiteral');
            console.debug(playBackReturn as any as string);
            console.groupEnd();
        }
        return playBackReturn;
    }

    public getCachedBySignature<T extends object>(signatureStr: string): T {
        if (this._objectsBySignature.get(signatureStr)) {
            return this._objectsBySignature.get(signatureStr);
        } else {
            return null;
        }
    }

    private validatingMetaFieldsExistence(entityType: Type<any>): void {
        const camposControleArr = [
            this.jsHbManager.jsHbConfig.jsHbCreationIdName,
            this.jsHbManager.jsHbConfig.jsHbMetadatasName,
            // this.jsHbManager.jsHbConfig.jsHbHibernateIdName,
            // this.jsHbManager.jsHbConfig.jsHbIdName,
            // this.jsHbManager.jsHbConfig.jsHbIdRefName,
            // this.jsHbManager.jsHbConfig.jsHbIsLazyUninitializedName,
            // this.jsHbManager.jsHbConfig.jsHbSignatureName,
            JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME,
            JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME];
        for (let index = 0; index < camposControleArr.length; index++) {
            const internalKeyItem = camposControleArr[index];
            if (Object.keys(entityType.prototype).lastIndexOf(internalKeyItem.toString()) >= 0) {
                throw new Error('The Entity ' + entityType.name + ' already has the property \'' + internalKeyItem.toString() + '\' offined!');
            }            
        }
    }

    public processJsHbResultEntityArrayInternal<L>(entityType: Type<L>, lazyLoadedColl: any, literalResultField: any[]): Observable<void> {
        let thisLocal = this;
        let refMap: Map<Number, any> = new Map();

        let realItemObsArr: Observable<L>[] = []
        for (const literalItem of literalResultField) {                               
            let realItem$: Observable<L> = this.processJsHbResultEntityPriv(entityType, literalItem, refMap);
            realItemObsArr.push(realItem$);
        }
        return combineLatest(realItemObsArr)
            .pipe(
                map((realItemArr) => {
                    for (const realItem of realItemArr) {                               
                        thisLocal.addOnCollection(lazyLoadedColl, realItem);
                    }
                })
            );
    }

    public processJsHbResultEntityInternal<L>(entityType: Type<L>, literalResultField: any): Observable<L> {
        let refMap: Map<Number, any> = new Map();
        return this.processJsHbResultEntityPriv(entityType, literalResultField, refMap);
    }

    private processJsHbResultEntityPriv<L>(entityType: Type<L>, literalResultField: any, refMap: Map<Number, any>): Observable<L> {
        //let signatureStr: string = <string>lodashGet(literalResultField, this.jsHbManager.jsHbConfig.jsHbSignatureName);
        let resultObsArr: Observable<any>[] = [];
        if (!literalResultField) {
            throw new Error('literalResultField nao pode ser nula');
        }
        let allMD = this.resolveMetadatas({literalObject: literalResultField})
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalResultField, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(literalResultField, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        let entityValue: L = this._objectsBySignature.get(backendMetadatas.$signature$);

        if (!entityValue) {
            //let jsHbIdRef: Number = <Number>lodashGet(literalResultField, this.jsHbManager.jsHbConfig.jsHbIdRefName);
            //if (jsHbIdRef) {
            if (backendMetadatas.$idRef$) {
                entityValue = refMap.get(backendMetadatas.$idRef$);
            }
        }
        
        if (!entityValue) {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.debug('entity was not processed yet on this session. Not found by signature: ' + backendMetadatas.$signature$);
            }
            this.validatingMetaFieldsExistence(entityType);
            entityValue = new entityType();
            lodashSet(entityValue as any, JsHbContants.JSHB_ENTITY_SESION_PROPERTY_NAME, this);
            this.removeNonUsedKeysFromLiteral(entityValue as any, literalResultField);

            //if (lodashHas(literalResultField, this.jsHbManager.jsHbConfig.jsHbIdName)) {
            if (backendMetadatas.$id$) {
                //refMap.set(<Number>lodashGet(literalResultField, this.jsHbManager.jsHbConfig.jsHbIdName), entityValue);
                refMap.set(backendMetadatas.$id$, entityValue);
            } else {
                throw new Error('This should not happen 1');
            }

            lodashSet(entityValue as any, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, true);
            try {
                this.tryCacheInstanceBySignature(
                    {
                        realInstance: entityValue, 
                        literalJsHbResult: literalResultField
                    }
                );
                lodashMergeWith(entityValue as any, literalResultField, this.mergeWithCustomizerPropertyReplection(refMap, resultObsArr));
            } finally {
                lodashSet(entityValue as any, JsHbContants.JSHB_ENTITY_IS_ON_LAZY_LOAD_NAME, false);
            }
        } else {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.debug('entity already processed on this session. Found by signature: ' + backendMetadatas.$signature$);
            }
        }

        let createSerialAsyncTasksWaiting$ = this.createSerialAsyncTasksWaiting();

        const isDone = { value: false };
        createSerialAsyncTasksWaiting$.subscribe(() => {
            isDone.value = true;
        });
        if (isDone.value) {
            return of(entityValue);
        } else {
            return this.createSerialAsyncTasksWaiting().pipe(
                map(() => {
                    return entityValue;
                })
            );
        }
    }

    private createLoadedLazyRef<L extends object, I>(genericNode: GenericNode, literalLazyObj: any, refMap: Map<Number, any>, refererObj: any, refererKey: string): Observable<LazyRef<L, I>> {
        let lr: LazyRef<L, I> = this.createApropriatedLazyRef<L, I>(genericNode, literalLazyObj, refererObj, refererKey);
        
        let trySetHibernateIdentifier$ = this.trySetHibernateIdentifier(lr, genericNode, literalLazyObj, refMap);
        let tryGetFromObjectsBySignature$ = this.tryGetFromObjectsBySignature(lr, literalLazyObj);
        let setLazyObjOnLazyLoading$: Observable<void> = of(null);
        let lazyLoadedObj$: Observable<void> = of(null);

        const isValueByFieldProcessor: {value: boolean} = { value: false };

        if (lr.lazyLoadedObj) {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.group('LazyRef.lazyLoadedObj is already setted: ');
                console.debug(lr.lazyLoadedObj);
                console.groupEnd();
            }
        } else {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.debug('LazyRef.lazyLoadedObj is not setted yet');
            }
            let lazyLoadedObjType: Type<any> = null;
            if (genericNode.gParams[0] instanceof GenericNode) {
                lazyLoadedObjType = (<GenericNode>genericNode.gParams[0]).gType;
            } else {
                lazyLoadedObjType = <Type<any>>genericNode.gParams[0];
            }
            
            //lr.setLazyObjOnLazyLoading(null);
            if (this.isCollection(lazyLoadedObjType)) {
                if (!(genericNode.gParams[0] instanceof GenericNode) || (<GenericNode>genericNode.gParams[0]).gParams.length <=0) {
                    throw new Error('LazyRef is not correctly defined: \'' + refererKey + '\' on ' + refererObj.constructor);
                }
                let collTypeParam: Type<any> =  null;
                if ((<GenericNode>genericNode.gParams[0]).gParams[0] instanceof GenericNode) {
                    collTypeParam = (<GenericNode>(<GenericNode>genericNode.gParams[0]).gParams[0]).gType;
                } else {
                    collTypeParam = <Type<any>>(<GenericNode>genericNode.gParams[0]).gParams[0];
                }

                setLazyObjOnLazyLoading$ = lr.setLazyObjOnLazyLoading(this.createCollection(lazyLoadedObjType, refererObj, refererKey));
                for (const {} of literalLazyObj) {
                    let realItem = this.processJsHbResultEntityPriv(collTypeParam, literalLazyObj, refMap);
                    this.addOnCollection(lr.lazyLoadedObj, realItem);
                }
            } else {
                let fieldEtc = JsHbManagerDefault.resolveFieldProcessorPropOptsEtc<L, any>(this.fielEtcCacheMap, refererObj, refererKey, this.jsHbManager.jsHbConfig);
                // let fieldProcessor: IFieldProcessor<L>;
                // let propertyOptions: NgJsHbDecorators.PropertyOptions<L> = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_HIBERNATE_PROPERTY_OPTIONS, refererObj, refererKey);
                // if (propertyOptions.fieldProcessorResolver) {
                //     fieldProcessor = propertyOptions.fieldProcessorResolver();
                // } else {
                //     fieldProcessor = this.jsHbManager.jsHbConfig.getTypeProcessor(lazyLoadedObjType);
                // }

                //if (!propertyOptions.isLazyProperty) {
                //let lazyLoadedObj;
                if (fieldEtc.prpGenType.gType === LazyRefPrpMarker) {
                    // if (fieldEtc.propertyOptions.lazyDirectRawRead) {
                    //     //nothing, it is loaded
                    // }
                    if (fieldEtc.fieldProcessorCaller.callFromLiteralValue) {
                        isValueByFieldProcessor.value = true;
                        let lazyLoadedObj$ = fieldEtc.fieldProcessorCaller.callFromLiteralValue(literalLazyObj, fieldEtc.fieldInfo);
                        // if (fieldEtc.propertyOptions.fieldProcessorEvents.onFromLiteralValue) {
                        //     fieldEtc.propertyOptions.fieldProcessorEvents.onFromLiteralValue(literalLazyObj, fieldEtc.fieldInfo, (lazyLoadedObj$ as any) as Observable<L>)
                        // }
                        // lazyLoadedObj$ = this.addSubscribedObservableForWaiting(lazyLoadedObj$);
                        lazyLoadedObj$ = lazyLoadedObj$.pipe(this.addSubscribedObservable());
                        lazyLoadedObj$.subscribe(
                            {
                                next: (value) => {
                                    lr.setLazyObjOnLazyLoading(value);
                                }
                            }
                        );
                    } else {
                        setLazyObjOnLazyLoading$ = lr.setLazyObjOnLazyLoading(literalLazyObj);
                    }
                } else {
                    setLazyObjOnLazyLoading$ = this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap)
                        .pipe(
                            flatMap((resultEntity) => {
                                return this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap);
                            })
                        );
                    // setLazyObjOnLazyLoading$ = lr.setLazyObjOnLazyLoading(this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap));                    
                }

                if (!isValueByFieldProcessor.value && genericNode.gType !== LazyRefPrpMarker) {
                    setLazyObjOnLazyLoading$ = this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap)
                        .pipe(
                            flatMap((resultEntity) => {
                                return this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap);
                            })
                        );
                    // setLazyObjOnLazyLoading$ = lr.setLazyObjOnLazyLoading(this.processJsHbResultEntityPriv(lazyLoadedObjType, literalLazyObj, refMap));
                }
            }
        }
        return trySetHibernateIdentifier$
            .pipe(
                flatMap(() => {
                    return tryGetFromObjectsBySignature$;
                })
            )
            .pipe(
                flatMap(() => {
                    return setLazyObjOnLazyLoading$
                })
            )
            .pipe(
                flatMap(() => {
                    return lazyLoadedObj$;
                })
            )
            .pipe(
                map(() => {
                    return lr;
                })
            );
        // return lr;
    }

    public tryCacheInstanceBySignature(
            tryOptions:
                {
                    realInstance: any,
                    literalJsHbResult: {result: any},
                    lazySignature?: string
                }): void {
        if (!tryOptions){
            throw new Error('tryOptions nao pode ser nula');
        }
        if (!tryOptions.literalJsHbResult){
            throw new Error('tryOptions.literalJsHbResult nao pode ser nula');
        }
        let allMD = this.resolveMetadatas({literalObject: tryOptions.literalJsHbResult});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(tryOptions.literalJsHbResult, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(tryOptions.literalJsHbResult, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        //let signatureStr: string = <string>lodashGet(tryOptions.literalJsHbResult, this.jsHbManager.jsHbConfig.jsHbSignatureName);
        //if (signatureStr) {
        if (backendMetadatas.$signature$) {
            this._objectsBySignature.set(backendMetadatas.$signature$, tryOptions.realInstance);
        }
        if (tryOptions.lazySignature) {
            this._objectsBySignature.set(tryOptions.lazySignature, tryOptions.realInstance);
        }
    }


    private createNotLoadedLazyRef<L extends object, I>(genericNode: GenericNode, literalLazyObj: any, refMap: Map<Number, any>, refererObj: any, refererKey: string): Observable<LazyRef<L, I>> {
        let propertyOptions: NgJsHbDecorators.PropertyOptions<L> = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_HIBERNATE_PROPERTY_OPTIONS, refererObj, refererKey);
        if (!propertyOptions){
            throw new Error('@NgJsHbDecorators.property() not defined for ' + refererObj.constructor.name + '.' + refererKey);
        }
        let lr: LazyRef<L, I> = this.createApropriatedLazyRef<L, I>(genericNode, literalLazyObj, refererObj, refererKey);
        let trySetHibernateIdentifier$ = this.trySetHibernateIdentifier(lr, genericNode, literalLazyObj, refMap);
        let tryGetFromObjectsBySignature$ = this.tryGetFromObjectsBySignature(lr, literalLazyObj);

        if (lr.lazyLoadedObj) {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.group('LazyRef.lazyLoadedObj is already setted: ');
                console.debug(lr.lazyLoadedObj);
                console.groupEnd();
            }
        } else {
            const lazyInfo: LazyInfo<L> = {
                gNode: genericNode,
                propertyOptions: propertyOptions,
                literalLazyObj: literalLazyObj,
                ownerType: refererObj.constructor,
                lazyFieldType: genericNode.gParams[0] as Type<any>,
                fieldName: refererKey
            }
            
            if (!propertyOptions.lazyDirectRawRead) {
                lr.respObs = this.jsHbManager.httpLazyObservableGen.generateHttpObservable(lr.signatureStr, lazyInfo)
                    .pipe(
                        //In case of an error, this allows you to try again
                        catchError((err) => {
                            lr.respObs = this.jsHbManager.httpLazyObservableGen.generateHttpObservable(lr.signatureStr, lazyInfo);
                            return throwError(err);
                        })
                    );
            } else {
                lr.respObs = this.jsHbManager.httpLazyObservableGen.generateHttpObservableForDirectRaw(lr.signatureStr, lazyInfo)
                    .pipe(
                        //In case of an error, this allows you to try again
                        catchError((err) => {
                            lr.respObs = this.jsHbManager.httpLazyObservableGen.generateHttpObservableForDirectRaw(lr.signatureStr, lazyInfo);
                            return throwError(err);
                        })
                    );
            }
        }
        return trySetHibernateIdentifier$
            .pipe(
                flatMap(() => {
                    return tryGetFromObjectsBySignature$;
                })
            )
            .pipe(
                map(() => {
                    return lr;
                })
            );
    }

    private tryGetFromObjectsBySignature<L extends object, I>(lr: LazyRef<L, I>, literalLazyObj: any): Observable<void> {
        if (!literalLazyObj){
            throw new Error('literalLazyObj nao pode ser nula');
        }
        let allMD = this.resolveMetadatas({literalObject: literalLazyObj});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        //let signatureStr: string = <string>lodashGet(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbSignatureName);

        let entityValue: any = null;
        if (backendMetadatas.$signature$) {
            lr.signatureStr = backendMetadatas.$signature$;
            entityValue = this._objectsBySignature.get(backendMetadatas.$signature$);
        } else {
        }

        if (entityValue) {
            return lr.setLazyObjOnLazyLoading(entityValue);
        } else {
            //nothing
            return of(null);
        }
    }

    public createApropriatedLazyRef<L extends object, I>(genericNode: GenericNode, literalLazyObj: any, refererObj: any, refererKey: string): LazyRef<L, I> {
        if (!literalLazyObj){
            throw new Error('literalLazyObj nao pode ser nula');
        }
        let allMD = this.resolveMetadatas({literalObject: literalLazyObj, refererObject: refererObj, key: refererKey});
        let backendMetadatas = allMD.objectMD;

        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }
        // let backendMetadatasRefererObj: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatasRefererObj = lodashGet(refererObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }

        let jsHbHibernateIdLiteral: any = backendMetadatas.$hibernateId$;
        let lazyRef: LazyRefDefault<L, any> = null;
        if (jsHbHibernateIdLiteral) {
            lazyRef = new LazyRefDefault<L, I>();
        } else {
            lazyRef = new LazyRefDefault<L, undefined>();
        }
        lazyRef.instanceId = this.nextMultiPurposeInstanceId();
        lazyRef.refererObj = refererObj;
        lazyRef.refererKey = refererKey;
        lazyRef.session = this;
        lazyRef.genericNode = genericNode;
        lazyRef.backendMetadatasLazyLoadedObj = allMD.objectMD;
        lazyRef.backendMetadatasRefererObj = allMD.refererObjMD;
        lazyRef.backendMetadatasHibernateIdMetadata = allMD.refererObjMD;
        return lazyRef;
    }

    private metadaKeys: Set<string>;
    private isLiteralObjMetadataKey(keyName: string): boolean {
        if (this.metadaKeys == null) {
            this.metadaKeys = new Set<string>()
                .add(this.jsHbManager.jsHbConfig.jsHbMetadatasName)
                // .add(this.jsHbManager.jsHbConfig.jsHbHibernateIdName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIdName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIdRefName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIsLazyUninitializedName)
                // .add(this.jsHbManager.jsHbConfig.jsHbSignatureName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIsAssociativeName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIsComponentName)
                // .add(this.jsHbManager.jsHbConfig.jsHbIsLazyPropertyName)
                ;
                
        }
        return this.metadaKeys.has(keyName);
    }

    private removeNonUsedKeysFromLiteral<L extends object>(realObj: L, literalObj: any) {
        let literalKeys: string[] = lodashClone(lodashKeys(literalObj));
        let realKeys: string[] = Object.keys(Object.getPrototypeOf(realObj));
        for (let index = 0; index < literalKeys.length; index++) {
            const keyItem = literalKeys[index];
            if (!this.isLiteralObjMetadataKey(keyItem) && realKeys.indexOf(keyItem) < 0) {
                delete literalObj[keyItem];
            }
        }
    }

    private trySetHibernateIdentifier<L extends object, I>(lr: LazyRef<L, I>, genericNode: GenericNode, literalLazyObj: any, refMap: Map<Number, any>): Observable<void> {
        let result$: Observable<void> = of(null);
        if (!literalLazyObj){
            throw new Error('literalLazyObj nao pode ser nula');
        }
        let allMD = this.resolveMetadatas({literalObject: literalLazyObj});
        let backendMetadatas = allMD.objectMD;
        // let backendMetadatas: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
        // if (lodashHas(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
        //     backendMetadatas = lodashGet(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbMetadatasName);
        // }

        //let jsHbHibernateIdLiteral: any = lodashGet(literalLazyObj, this.jsHbManager.jsHbConfig.jsHbHibernateIdName);
        let jsHbHibernateIdLiteral: any = backendMetadatas.$hibernateId$;
        if (jsHbHibernateIdLiteral instanceof Object && !(jsHbHibernateIdLiteral instanceof Date)) {
            let hbIdType: Type<any> = null;
            if (genericNode.gParams[1] instanceof GenericNode) {
                hbIdType = (<GenericNode>genericNode.gParams[1]).gType;
            } else {
                hbIdType = <Type<any>>genericNode.gParams[1];
            }
            if (hbIdType) {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.group('There is a hbIdType on LazyRef. Is it many-to-one LazyRef?!. hbIdType: ' + hbIdType.name + ', genericNode:');
                    console.debug(genericNode);
                    console.groupEnd();
                }
                this.validatingMetaFieldsExistence(hbIdType);
                result$ = this.processJsHbResultEntityPriv(hbIdType, jsHbHibernateIdLiteral, refMap)
                    .pipe(
                        map((hbId) => {
                            lr.hbId = hbId;
                        })
                    );
                // lr.hbId = this.processJsHbResultEntityPriv(hbIdType, jsHbHibernateIdLiteral, refMap);
            } else {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.group('Thre is no hbIdType on LazyRef. Is it a collection?!. hbIdType: ' + hbIdType.name + ', genericNode:');
                    console.debug(genericNode);
                    console.groupEnd();
                }
            }
        } else if (jsHbHibernateIdLiteral) {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.group('The hibernate id is a simple type value: ' + jsHbHibernateIdLiteral + '. genericNode:');
                console.debug(genericNode);
                console.groupEnd();
            }
            lr.hbId = jsHbHibernateIdLiteral;
        } else {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.group('The hibernate id is null! Is it a collection?!: ' + jsHbHibernateIdLiteral + '. genericNode:');
                console.debug(genericNode);
                console.groupEnd();
            }
        }
        return result$;
    }

    public createCollection(collType: Type<any>, refererObj: any, refererKey: string): any {
        if (collType === Set) {
            return new JsHbSetCreator(this, refererObj, refererKey).createByProxy();
        } else {
            throw new Error('Collection not supported: ' + collType);
        }
    }

    public isCollection(typeTested: Type<any>): any {
        return (typeTested === Array)
                || (typeTested === Set);
    }

    public addOnCollection(collection: any, element: any) {
        if (collection instanceof Array) {
            throw new Error('Collection not supported: ' + (collection as any).prototype);
        } else if (collection instanceof Set){
            (<Set<any>>collection).add(element);
        } else {
            throw new Error('Collection not supported: ' + collection.prototype);
        }
    }
    public removeFromCollection(collection: any, element: any) {
        if (collection instanceof Array) {
            throw new Error('Collection not supported: ' + (collection as any).prototype);
        } else if (collection instanceof Set){
            (<Set<any>>collection).delete(element);
        } else {
            throw new Error('Collection not supported: ' + collection.prototype);
        }
    }

    private mergeWithCustomizerPropertyReplection(refMap: Map<Number, any>, resultObsArr: Observable<any>[]): MergeWithCustomizer {
        let thisLocal = this;
        return function (value: any, srcValue: any, key?: string, object?: Object, source?: Object) {
            const keepAllFlagsCallback = thisLocal.keepAllFlagsCallbackCreate(object);
            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                console.group('mergeWithCustomizerPropertyReplection => function');
                console.debug(refMap); console.debug(value); console.debug(srcValue); console.debug(key); console.debug(object); console.debug(source);
                console.groupEnd();
            }
            let allMD = thisLocal.resolveMetadatas({literalObject: srcValue, refererLiteralObject: source, key: key});
            let backendMetadatasSource = allMD.refererObjMD;
            let backendMetadatasSrcValue = allMD.objectMD;
            let backendMetadatasHibernateIdMetadata = allMD.hibernateIdMD;
            let backendMetadatasSrcValueFound = allMD.objectMDFound;
            // if (lodashHas(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            //     backendMetadatasSrcValue = lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName);
            //     backendMetadatasSrcValueFound = true;
            // }
            // let backendMetadatasSource: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
            // let backendMetadatasSrcValue: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
            // let backendMetadatasHibernateIdMetadata: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
            // let backendMetadatasSrcValueFound = false;
            // if (lodashHas(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            //     backendMetadatasSrcValue = lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName);
            //     backendMetadatasSrcValueFound = true;
            // }
            // if (source && lodashHas(source, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            //     backendMetadatasSource = lodashGet(source, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName);
            // }
            //we are processing the metadata
            // if (key === thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName 
            //         && (srcValue as JsHbBackendMetadatas).$iAmJsHbBackendMetadatas$
            //         && lodashHas((srcValue as JsHbBackendMetadatas).$hibernateId$, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            //     if (lodashHas((srcValue as JsHbBackendMetadatas).$hibernateId$, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName)) {
            //         backendMetadatasHibernateIdMetadata = lodashGet((srcValue as JsHbBackendMetadatas).$hibernateId$, thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName);
            //     }
            // }

            let fieldEtc = JsHbManagerDefault.resolveFieldProcessorPropOptsEtc(thisLocal.fielEtcCacheMap, object, key, thisLocal.jsHbManager.jsHbConfig);
            //let prpType: Type<any> = Reflect.getMetadata('design:type', object, key);
            //let prpGenType: GenericNode = GenericTokenizer.resolveNode(object, key);
            //let isJsHbHibernateIdAndIsObject: boolean = false;
            // let jsHbIsComponent: boolean = false;
            // let jsHbIsAssociative: boolean = false;
            // let jsHbIsLazyProperty: boolean = false;
            // if (srcValue instanceof Object) {
            //     jsHbIsComponent = lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIsComponentName);
            //     jsHbIsAssociative = lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIsAssociativeName);
            //     jsHbIsLazyProperty = lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIsLazyPropertyName);
            // }
            // lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.)
            //if (!prpType && backendMetadatasSrcValue.isComponent && key === thisLocal.jsHbManager.jsHbConfig.jsHbHibernateIdName) {
            if (backendMetadatasHibernateIdMetadata.$isComponent$) {
                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                    //console.group('mergeWithCustomizerPropertyReplection => function: (!prpType && srcValue instanceof Object && !(srcValue instanceof Date) && key === thisLocal.jsHbManager.jsHbConfig.jsHbHibernateIdName)');
                    console.group('mergeWithCustomizerPropertyReplection => function: backendMetadatasHibernateId.isComponent. backendMetadatasSrcValue.hibernateId:');
                    console.debug(backendMetadatasSrcValue.$hibernateId$);
                    console.groupEnd();
                }
                fieldEtc.prpType = Reflect.getMetadata(JsHbContants.JSHB_REFLECT_METADATA_HIBERNATE_ID_TYPE, object);
                if (!fieldEtc.prpType) {
                    throw new Error('We are receiving backendMetadatas.hibernateId as Object and ' + object.constructor.name + ' does not define a property with @NgJsHbDecorators.hibernateId()');
                }
            }
            //if (jsHbIsLazyProperty) {
            // if (backendMetadatasSrcValue.$isLazyProperty$) {
            //     throw new Error('Lazy property not supported! Key '+ object.constructor.name + '.' + key);
            // }
            //if (jsHbIsAssociative && prpGenType && prpGenType.gType !== LazyRef) {
            if (backendMetadatasSrcValue.$isAssociative$ && fieldEtc.prpGenType && fieldEtc.prpGenType.gType !== LazyRef) {
                throw new Error('Key '+ object.constructor.name + '.' + key + ' is hibernate associative relation and is not LazyRef or not define GenericTokenizer');
            }
            //if (jsHbIsComponent && prpGenType && prpGenType.gType === LazyRef) {
            if (backendMetadatasSrcValue.$isComponent$ && fieldEtc.prpGenType && fieldEtc.prpGenType.gType === LazyRef) {
                throw new Error('Key '+ object.constructor.name + '.' + key + ' is hibernate component and is a LazyRef.');
            }
            let correctSrcValue = srcValue;
            if (key === thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName) {
                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                    console.group('mergeWithCustomizerPropertyReplection => function: (key === thisLocal.jsHbManager.jsHbConfig.jsHbMetadatasName). srcValue:');
                    console.debug(srcValue);
                    console.groupEnd();
                }
                let correctSrcValueAsMetadata: JsHbBackendMetadatas = { $iAmJsHbBackendMetadatas$: true };
                Object.assign(correctSrcValueAsMetadata, srcValue);
                if (backendMetadatasHibernateIdMetadata.$isComponent$) {
                    correctSrcValueAsMetadata.$hibernateId$ = thisLocal.processJsHbResultEntityPriv(fieldEtc.prpType, (srcValue as JsHbBackendMetadatas).$hibernateId$, refMap);
                }
                correctSrcValue = correctSrcValueAsMetadata;

                //here prpType 
            } else if (backendMetadatasSrcValue.$idRef$) {
                //let jsHbIdRef: Number = <Number>lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIdRefName);
                //if (jsHbIdRef) {
                //correctSrcValue = refMap.get(jsHbIdRef);
                correctSrcValue = refMap.get(backendMetadatasSrcValue.$idRef$);
                if (!correctSrcValue) {
                    throw new Error('This should not happen 2');
                }
                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                    //console.group('mergeWithCustomizerPropertyReplection => function. Object resolved by ' + thisLocal.jsHbManager.jsHbConfig.jsHbIdRefName + ' field');
                    console.group('mergeWithCustomizerPropertyReplection => function. Object resolved by backendMetadatas.idRef field');
                    console.debug(correctSrcValue);
                    console.groupEnd();
                }
            //} else if (isJsHbHibernateIdAndIsObject || jsHbIsComponent) {
            } else if (fieldEtc.prpType) {
                const isFromLiteralValue = {value: false};
                if (fieldEtc.prpGenType) {
                    if (thisLocal.isCollection(fieldEtc.prpGenType.gType)) {
                        if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                            console.group('mergeWithCustomizerPropertyReplection => function. thisLocal.isCollection(prpGenType.gType) ');
                            console.debug(fieldEtc.prpGenType); console.debug(fieldEtc.prpGenType.gType);
                            console.groupEnd();
                        }
                        let correctSrcValueColl = thisLocal.createCollection(fieldEtc.prpGenType.gType, object, key);
                        for (let index = 0; index < srcValue.length; index++) { 
                            let arrItemType: Type<any> = <Type<any>>fieldEtc.prpGenType.gParams[0];
                            let correctSrcValueCollItem = thisLocal.processJsHbResultEntityPriv(arrItemType, srcValue[index], refMap);
                            thisLocal.addOnCollection(correctSrcValueColl, correctSrcValueCollItem);
                        }
                        correctSrcValue = correctSrcValueColl;
                        //nothing for now
                    } else if (fieldEtc.prpGenType.gType === LazyRef || fieldEtc.prpGenType.gType === LazyRefPrpMarker) {
                        //if (!lodashHas(source, thisLocal.jsHbManager.jsHbConfig.jsHbIdName)) {
                        if (!backendMetadatasSource.$id$) {
                            //throw new Error('There is no \'' + thisLocal.jsHbManager.jsHbConfig.jsHbIdName + '\' on ' + JSON.stringify(srcValue));
                            throw new Error('There is no backendMetadatas.id on ' + JSON.stringify(srcValue));
                        }
                        //if (!jsHbIsAssociative && !jsHbIsLazyProperty) {
                        if (backendMetadatasSrcValueFound && !backendMetadatasSrcValue.$isAssociative$ && !backendMetadatasSrcValue.$isLazyProperty$) {
                            throw new Error('Receiving object that is non associative an no lazy property but field a LazyRef type. field: ' + object.constructor.name + '.' + key + '. Value' + + JSON.stringify(srcValue));
                        }
                        //let refId: Number = <Number>lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIdName);
                        //if (lodashGet(srcValue, thisLocal.jsHbManager.jsHbConfig.jsHbIsLazyUninitializedName)) {
                        if (backendMetadatasSrcValue.$isLazyUninitialized$) {
                            const lazyRefSyncSafe = { value: null as any };
                            let createNotLoadedLazyRef$ = thisLocal.createNotLoadedLazyRef(fieldEtc.prpGenType, srcValue, refMap, object, key);
                            createNotLoadedLazyRef$ = createNotLoadedLazyRef$.pipe(thisLocal.addSubscribedObservable());
                            createNotLoadedLazyRef$.subscribe(
                                {
                                    next: (lazyRef) => {
                                        if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                                            console.group('(Asynchronous of Asynchronous of...) mergeWithCustomizerPropertyReplection => function => createNotLoadedLazyRef$.subscribe(). createNotLoadedLazyRef, for property \''+key+'\'. lodashSet(object, key, lazyRef)');
                                            console.debug(object);
                                            console.groupEnd();
                                        }
                                        lazyRefSyncSafe.value = lazyRef;
                                        keepAllFlagsCallback(() => {
                                            lodashSet(object, key, lazyRef);
                                        })
                                    }
                                }
                            );
                            // let lazyRef: LazyRef<any, any> = thisLocal.createNotLoadedLazyRef(fieldEtc.prpGenType, srcValue, refMap, object, key);
                            // //there is no refId when 'jsHbIsLazyUninitialized'
                            // //refMap.set(refId, lazyRef);
                            // return lazyRef;
                            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                                console.group('mergeWithCustomizerPropertyReplection => function. Returning null because of createNotLoadedLazyRef$.subscribe(). property \''+key+'\'.');
                                console.debug(object);
                                console.groupEnd();
                            }
                            return lazyRefSyncSafe.value;
                        } else {
                            const lazyRefSyncSafe = { value: null as any };
                            let createNotLoadedLazyRef$ = thisLocal.createLoadedLazyRef(fieldEtc.prpGenType, srcValue, refMap, object, key);
                            createNotLoadedLazyRef$ = createNotLoadedLazyRef$.pipe(thisLocal.addSubscribedObservable());
                            //sync safe return
                            createNotLoadedLazyRef$.subscribe(
                                {
                                    next: (lazyRef) => {
                                        if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                                            console.group('(Asynchronous of Asynchronous of...) mergeWithCustomizerPropertyReplection => function => createLoadedLazyRef$.subscribe(). createLoadedLazyRef, for property \''+key+'\'. lodashSet(object, key, lazyRef)');
                                            console.debug(object);
                                            console.groupEnd();
                                        }
                                        lazyRefSyncSafe.value = lazyRef;
                                        keepAllFlagsCallback(() => {
                                            lodashSet(object, key, lazyRef);
                                        })
                                    }
                                }
                            );
                            // let lazyRef: LazyRef<any, any> = thisLocal.createLoadedLazyRef(fieldEtc.prpGenType, srcValue, refMap, object, key);
                            // //refMap.set(refId, lazyRef);
                            // refMap.set(backendMetadatasSrcValue.$id$, lazyRef);
                            // return lazyRef;
                            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                                console.group('mergeWithCustomizerPropertyReplection => function. Returning null because of createNotLoadedLazyRef$.subscribe(). property \''+key+'\'.');
                                console.debug(object);
                                console.groupEnd();
                            }
                            return lazyRefSyncSafe.value;
                        }
                    }
                } else if (srcValue instanceof Object
                        && !(srcValue instanceof Date)
                        && !fieldEtc.propertyOptions.lazyDirectRawRead) {
                    const correctSrcValueSyncSafe = { value: null as any };
                    let processJsHbResultEntityPriv$ = thisLocal.processJsHbResultEntityPriv(fieldEtc.prpType, srcValue, refMap);
                    processJsHbResultEntityPriv$ = processJsHbResultEntityPriv$
                        .pipe(thisLocal.addSubscribedObservable());
                    processJsHbResultEntityPriv$.subscribe(
                        {
                            next(correctSrcValueSubs) {
                                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                                    console.group('(Asynchronous of Asynchronous of...) mergeWithCustomizerPropertyReplection => function => processJsHbResultEntityPriv$.subscribe(). createLoadedLazyRef, for property \''+key+'\'. lodashSet(object, key, correctSrcValue)');
                                    console.debug(object);
                                    console.groupEnd();
                                }
                                correctSrcValueSyncSafe.value = correctSrcValueSubs;
                                keepAllFlagsCallback(() => {
                                    lodashSet(object, key, correctSrcValueSubs);
                                })
                            }
                        }
                    );
                    if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                        console.group('mergeWithCustomizerPropertyReplection => function. Returning null because of processJsHbResultEntityPriv$.subscribe(). property \''+key+'\'.');
                        console.debug(object);
                        console.groupEnd();
                    }
                    return correctSrcValueSyncSafe.value;
                    // correctSrcValue = thisLocal.processJsHbResultEntityPriv(fieldEtc.prpType, srcValue, refMap);
                    // //throw new Error('There is no GenericTokenizer for '+ object.constructor.name + '.' + key);
                } else if (fieldEtc.fieldProcessorCaller.callFromLiteralValue) {
                    if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                        console.group('mergeWithCustomizerPropertyReplection => function. Transformation by "IFieldProcessor.fromLiteralValue" for property \''+key+'\'.');
                        console.debug(object);
                        console.groupEnd();
                    }
                    const correctSrcValueSyncSafe = { value: null as any };
                    isFromLiteralValue.value = true;
                    let fromLiteralValue$ = fieldEtc.fieldProcessorCaller.callFromLiteralValue(correctSrcValue, fieldEtc.fieldInfo);
                    fromLiteralValue$ = fromLiteralValue$
                        .pipe(thisLocal.addSubscribedObservable())
                        .pipe(thisLocal.keepAllFlagsRxOpr(object, (fromLiteralValue) => { return fromLiteralValue; }));
                    fromLiteralValue$.subscribe((correctSrcValueFlv) => {
                        if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                            console.group('(Asynchronous of Asynchronous of...) mergeWithCustomizerPropertyReplection => function => fromLiteralValue$.subscribe(). fromLiteralValue, for property \''+key+'\'. lodashSet(object, key, correctSrcValue)');
                            console.debug(object);
                            console.groupEnd();
                        }
                        correctSrcValueSyncSafe.value = correctSrcValueFlv;
                        keepAllFlagsCallback(() => {
                            lodashSet(object, key, correctSrcValueFlv);
                        })
                        // //it is necessary for execution at same js turn
                        // correctSrcValue = correctSrcValueFlv;
                    });
                    if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                        console.group('mergeWithCustomizerPropertyReplection => function. Returning null because of fromLiteralValue$.subscribe(). property \''+key+'\'.');
                        console.debug(object);
                        console.groupEnd();
                    }
                    return correctSrcValueSyncSafe.value;
                } else {
                    if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                        console.group('mergeWithCustomizerPropertyReplection => function. Transformation is not necessary for property \''+key+'\'.');
                        console.debug(object);
                        console.groupEnd();
                    }
                }
            } else if (lodashHas(object, key)) {
                throw new Error('No type decorator for '+ object.constructor.name + '.' + key);
            } else if (!lodashHas(object, key) && !thisLocal.isLiteralObjMetadataKey(key)) {
                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                    console.debug('mergeWithCustomizerPropertyReplection => function. This property \''+key+'\' does not exists on this type.');
                }
                correctSrcValue = undefined;
            } else {
                if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                    console.group('mergeWithCustomizerPropertyReplection => function. Property \''+key+'\'. Using same value.');
                    console.debug(correctSrcValue);
                    console.groupEnd();
                }
            }
            if (JsHbLogLevel.Trace >= thisLocal.jsHbManager.jsHbConfig.logLevel) {
                console.group('mergeWithCustomizerPropertyReplection => function. return');
                console.debug(correctSrcValue);
                console.groupEnd();
            }

            return correctSrcValue;
        }
    }

    public registerEntityAndLazyref(entity: object, lazyRef: LazyRef<any, any>): void {
        if (!lazyRef.isLazyLoaded()) {
            throw new Error('Can not register: !lazyRef.isLazyLoaded(). \n' + this.toString());
        }
        if (lazyRef.lazyLoadedObj !== entity) {
            throw new Error('Can not register: entity !== lazyRef.lazyLoadedObj. \n' + this.toString());
        }
        if (!this._lazyrefsByEntityMap.has(entity)) {
            this._lazyrefsByEntityMap.set(entity, new Set());
        }

        this._lazyrefsByEntityMap.get(entity).add(lazyRef);
    }
    public unregisterEntityAndLazyref(entity: object, lazyRef: LazyRef<any, any>): void {
        if (!lazyRef.isLazyLoaded()) {
            throw new Error('Can not unregister: !lazyRef.isLazyLoaded(). \n' + this.toString());
        }
        if (lazyRef.lazyLoadedObj === entity) {
            throw new Error('Can not unregister: entity === lazyRef.lazyLoadedObj. \n' + this.toString());
        }
        if (!this._lazyrefsByEntityMap.has(entity)
                || this._lazyrefsByEntityMap.get(entity).size <= 0) {
            throw new Error('Can not unregister: entity has no lazyRef associated. \n' + this.toString());
        }
        this._lazyrefsByEntityMap.get(entity).delete(lazyRef);
    }
    public notifyAllLazyrefsAboutEntityModification(entity: object, lazyRefSource: LazyRef<any, any>): void {
        if (this._switchedOffNotificationEntitiesSet.has(entity)) {
            if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                console.group('JsHbSessionDefault.notifyLazyrefAboutEntityModification: this._switchOffEntitiesSet.has(entity): entity modified but modifying notification is switched off!. entity:');
                console.debug(entity);
                console.groupEnd();
            }
        } else {
            if (!lazyRefSource) {
                if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                    console.group('JsHbSessionDefault.notifyLazyrefAboutEntityModification: !lazyRefSource: Am I been notified from a property set?!. entity:');
                    console.debug(entity);
                    console.groupEnd();
                }
            }
            if (lazyRefSource && !lazyRefSource.isLazyLoaded()) {
                throw new Error('Can not notify: !lazyRefSource.isLazyLoaded(). \n' + this.toString());
            }
            if (lazyRefSource && lazyRefSource.lazyLoadedObj !== entity) {
                throw new Error('Can not notify: entity !== lazyRefSource.lazyLoadedObj. \n' + this.toString());
            }
            // if (!this._lazyrefsByEntityMap.has(entity)
            //     || this._lazyrefsByEntityMap.get(entity).size <= 0) {
            //     throw new Error('Can not notify: entity has no lazyRef associated. \n' + this.toString());
            // }
            if (this._lazyrefsByEntityMap.has(entity)) {
                let lazyrefsArr: Array<LazyRef<any,any>> = Array.from(this._lazyrefsByEntityMap.get(entity));
                for (const lazyrefItem of lazyrefsArr) {
                    if (lazyRefSource === lazyrefItem) {
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.group('JsHbSessionDefault.notifyLazyrefAboutEntityModification: Not notifing: lazyRefSource === lazyrefItem. entity:');
                            console.debug(entity);
                            console.groupEnd();
                        }
                    } else {
                        if (!lazyrefItem.isLazyLoaded()) {
                            throw new Error('Can not notify: !lazyrefItem.isLazyLoaded(). \n' + this.toString());
                        }
                        if (lazyrefItem.lazyLoadedObj !== entity) {
                            throw new Error('Can not notify: lazyrefItem.lazyLoadedObj !== entity. \n' + this.toString());
                        }
                        if (JsHbLogLevel.Trace >= this.jsHbManager.jsHbConfig.logLevel) {
                            console.group('JsHbSessionDefault.notifyLazyrefAboutEntityModification: Notifing: lazyRefSource !== lazyrefItem.\n lazyRefSource and lazyrefItem:\n'+lazyRefSource+'\n'+lazyrefItem+'\n an . entity:');
                            console.debug(entity);
                            console.groupEnd();
                        }
                        lazyrefItem.notifyModification(entity);
                    }
                }
            }
        }
    }

    switchOffNotifyAllLazyrefs(entity: object): void {
        this._switchedOffNotificationEntitiesSet.add(entity);
    }
    switchOnNotifyAllLazyrefs(entity: object): void {
        this._switchedOffNotificationEntitiesSet.delete(entity);
    }

    private _nextMultiPurposeInstanceId = 1;
    /** Framework internal use. */
    nextMultiPurposeInstanceId(): number {
        return this._nextMultiPurposeInstanceId++;
    }
}